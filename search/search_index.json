{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This project is an analysis tool designed to perform fundamental analysis on publicly traded equities using a variety of methods. From various studies and research, fundamental analysis is an imperfect science. There's no \"silver bullet\" that tells you whether a company will be successful or and epic failure.</p> <p>Likewise it's impossible to predict the future of the stock market by any reasonable measure. Doing so would be a fools errand. However, with enough time and patience, fundamental analysis can help improve your odds by helping to understand the intrinsic value of a company despite the rise and fall of stock prices. Check your emotions at the door and prepare to focus on fundamental analysis.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Requirements: python 3.10+</p>"},{"location":"getting-started/#install","title":"Install","text":"pipgit <pre><code># basic install\npip install stocktracer\n\n# with tensorflow dependencies for analysis modules\npip install stocktracer[tensorflow]\n# Perform analysis\nstocktracer analyze --tickers aapl,msft &gt; report.txt\n\n# Help\nstocktracer\n</code></pre> <pre><code># Clone Repository\ngit clone https://github.com/gyund/fundamental-analysis.git\ncd fundamental-analysis.git\n\n# Normal development install\npoetry install --sync # (1)!\n# With mkdocs\npoetry install --sync --with docs\n\n# with mkdocs and tensorflow dependency support\npoetry install --sync --extras \"tensorflow\"  --with docs\n\n# Perform analysis\nPYTHONPATH=src poetry run python -m stocktracer analyze --tickers aapl,msft\nPYTHONPATH=src poetry run python -m stocktracer analyze --tickers aapl,msft -a stocktracer.analysis.diluted_eps\nPYTHONPATH=src poetry run python -m stocktracer analyze --tickers aapl,msft -a stocktracer.analysis.diluted_eps --report-format csv\nPYTHONPATH=src poetry run python -m stocktracer analyze --tickers aapl,msft -a stocktracer.analysis.diluted_eps --report-format json --report-file my_results.json\n\n# Help\nPYTHONPATH=src poetry run python -m stocktracer\n\n# Run Unit Tests\npoetry run pytest\n</code></pre> <ol> <li>Make sure you have poetry installed.</li> </ol>"},{"location":"getting-started/#generating-a-basic-report","title":"Generating a Basic Report","text":"pipgit <pre><code># Perform analysis\nstocktracer analyze --tickers appl,msft &gt; report.txt\n</code></pre> <pre><code># Perform analysis\npython -m stocktracer analyze --tickers aapl,msft &gt; report.txt\n</code></pre> <p>Tip</p> <p>If you want to figure out a list of tags you can filter the reports on, run the default analysis report. This shows the annual report and will then filter out any columns that contain <code>null</code> or <code>NaN</code> values. From here, you can establish what algorithms you can use and apply consistently across the stocks of interest. You may find that different sectors or 10-K/10-Q reports will have different data sets.</p>"},{"location":"getting-started/#plugins","title":"Plugins","text":"<p>If you wish to use your own analysis plugin, create your own module that implements this interface:</p> <pre><code>from ticker.data.sec import DataSelector as SecDataSelector\nfrom ticker.filter import Selectors,SecFilter\ndef analyze(options: Options) -&gt; None:\nprint(\"This is where we would start to process information, but we're not right now\")\n</code></pre> <p>Then call the tool in the following manner:</p> <pre><code>python -m ticker analyze --tickers aapl,msft --analysis_plugin 'mypkg.analysis'\n</code></pre>"},{"location":"getting-started/#testing","title":"Testing","text":"<p>Run tests by running the following:</p> <pre><code>pytest\n</code></pre> <p>If you wish to run tests using real network resources, such as downloading real reports and processing them, run the following:</p> <pre><code>pytest --run-webtest\n</code></pre> <p>Note that all data sets will be cached in the directory <code>${cwd}/.ticker-cache/</code> for both real and test runs. Expiry for quarterly reports are cached for 5 years and ticker mappings for <code>CIK -&gt; Ticker</code> conversion are cached on a yearly basis. You generally won't be researching companies with less than a year's worth of reports though this could cause recently listed companies to lack <code>CIK -&gt; Ticker</code> conversions for up to two years from poor timing. Just delete <code>${cwd}/.ticker-cache/tickers.sqlite</code> to get the latest.</p>"},{"location":"analysis/annual-reports/","title":"Annual Reports","text":"<p>Experimental</p> <p>This analysis module grabs the annual reports and data associated data.</p>"},{"location":"analysis/annual-reports/#example","title":"Example","text":"commandoutput"},{"location":"analysis/diluted-eps/","title":"Diluted EPS","text":"<p>Experimental</p> <p>Calculate the diluted EPS for the past 5 years for the requested stocks.</p>"},{"location":"analysis/diluted-eps/#example","title":"Example","text":"commandoutput"},{"location":"analysis/f-score/","title":"F-Score","text":"<p>Experimental</p> <p>This is not yet complete.</p> <p>Calculate the F-Score. </p>"},{"location":"analysis/f-score/#example","title":"Example","text":"commandoutput"},{"location":"analysis/tensorflow/","title":"Tensorflow","text":"<p>Experimental</p> <p>This is currently very experimental. The current state consists of essentially having training data and data to analyze get processed by the model. However, that's about it.</p> <p>To get started, you need to install the tensorflow dependencies:</p> pipgit <pre><code>pip install stocktracer[tensorflow]\n</code></pre> <pre><code>poetry install --sync --extras \"tensorflow\" </code></pre> <p>The idea with this analysis module is to leverage tensorflow to create a training model of stocks that match a particular criteria and ones that don't. For example, label a group of stocks as \"good\" and another group as \"bad\". Then use the tensorflow decision trees to categorize other unknown stocks as \"good\" or \"bad\" based on their attributes.</p>"},{"location":"analysis/tensorflow/#example","title":"Example","text":"commandoutput"},{"location":"design/","title":"The Big Picture","text":"<p>The general approach is as follows:</p> <ul> <li>Provide a flexible way to gather and collect information from a variety of data sources</li> <li>Collect the data and cache it</li> <li>Process the data and make sense of it</li> <li>Create a report based on the data collected at the time</li> <li>Run this report on a periodic basis</li> </ul> <p>Output formats could be as follows:</p> <ul> <li>JSON</li> <li>CSV</li> <li>Text</li> </ul>"},{"location":"design/analysis/","title":"Performing Data Analysis","text":"<p>The first problem to tackle is how to narrow down the number of companies that would be fundamentally sound enough to invest in. To do this, we need to answer the following questions:</p> <ul> <li>Is the company making a profit</li> <li>Are the company's sales growing</li> <li>How is the future outlook of the company?</li> <li>How are economic changes going to impact the growth scenario of the company?</li> </ul> <p>To begin processing the data we will be using</p> <p>TODO</p> <p>Figure out what library to use</p>"},{"location":"design/analysis/#weed-out","title":"Weed Out","text":"<p>There are over 5000 companies traded publicly traded, but performing analysis on them all might be somewhat excessive. The first criteria to remove the following:</p> <ul> <li>Companies not making a profit</li> <li>Companies that have a risky level of debt</li> </ul> <p>From here, you can perform sector analysis on companies to determine outliers. What are normal sales ratios, etc.</p>"},{"location":"design/analysis/#metrics","title":"Metrics","text":"<p>There are a variety of metrics we can then look at for further scrutiny:</p> <ul> <li>Debt/Equity Ratio</li> <li>P/B Ratio (price to book ratio)</li> <li>P/E (price-to-earnings ratio)</li> <li>Profit Margins</li> <li>ROE Ratio (return on equity)</li> </ul>"},{"location":"design/analysis/#the-fed","title":"The Fed","text":"<ul> <li>Evaluate interest rate risk</li> <li>Evaluate the bond market</li> <li>Look at the yield curve</li> <li>Look at the Consumer Price Index</li> <li>Look at inflation, present and forecast</li> </ul>"},{"location":"design/analysis/#scoring","title":"Scoring","text":"<p>We can then apply a scoring methodology that weights companies based on a variety of metrics and use it to gauge investment risk.</p>"},{"location":"design/caching/","title":"Slow is Fast","text":"<p>It's important not to rush past figuring out where performance is a problem and where it can be improved. As we encounter areas where performance is/was a problem, we'll post a writeup here.</p>"},{"location":"design/caching/#network","title":"Network","text":"<p>We want to be responsible citizens when downloading from the SEC website. Generally, the defaults are as follows:</p> Description Cache Duration Typical Size CIK Tickers 1 Year &lt; 1MB Quarterly Data Dumps 5 Years ~50MB per quarter <p>We experimented with a few different caches. What seemed to perform reasonably well was SQLite with pickled serialization. Initially we thought that FileCache would have performed well, but it seems that serializing to JSON may have been impacting the performance.</p>"},{"location":"design/data-retrieval/","title":"Data Retrieval","text":"<p>There's is A LOT of data, and we can't download gigabytes of data. The general idea is that we:</p> <ul> <li>Provide a list of tickers to retrieve reports for</li> <li>Download and cache the reports for those tickers (cache works by starting from the last report date to the present)</li> <li>Delete reports that are too old to be useful</li> <li>Perform analysis on them</li> <li>If the ticker is considered \"garbage quality\", we will put it in the list of stocks not to query again in the future. If it is ever suggested again, there will be a warning but it will be silently ignored unless the user wants to override it. We will delete the cache of Edgar reports for stocks that are considered \"garbage\".</li> </ul>"},{"location":"design/data-retrieval/#edgar-downloads","title":"Edgar Downloads","text":""},{"location":"design/data-retrieval/#sec-financial-data-sets","title":"SEC Financial Data Sets","text":"<p>Planned Approach</p> <p>Source: Financial Data Sets</p> <p>The SEC provides data sets in the form of compressed text files. The quarterly downloads are around 50MB but they decompress to a couple hundred MB.</p> <p>The important parts of the zip file are as follows:</p> <ul> <li>sub.txt</li> <li>num.txt</li> </ul> <p>This <code>sub.txt</code> file contains contents similar to the following:</p> sub.txt<pre><code>0000320193-23-000006    320193  APPLE INC   3571    US  CA  CUPERTINO   95014   ONE APPLE PARK WAY      (408) 996-1010  US  CA  CUPERTINO   95014   ONE APPLE PARK WAY      US  CA  942404110   APPLE INC   20070109    1-LAF   0   0930    10-Q    20221231    2023    Q1  20230203    2023-02-02 18:02:00.0   0   1   aapl-20221231_htm.xml   1\n</code></pre> <p>The first item contains the adsh value. This essentially maps to the document that contains all the information for this report. The <code>cik</code> is the second number. This is what is commonly used to identify the company. Further down, we have a column that specifies the report. In this case, above we have a <code>10-Q</code> filing for a quarterly report. The second to last line also contains the xml file, which is conveniently prefixed with the ticker number of the company.</p> <p>The next document, <code>num.txt</code>, contains all the important financial information. Here's an example</p> num.txt<pre><code>0000320193-23-000006    AssetsCurrent   us-gaap/2022        20220930    0   USD 135405000000.0000   \n</code></pre> <p>You can see how easy it is now to pull financial information out of these data sets. In this one line, we can map the report to the value. In this case, the value corresponds to <code>AssetsCurrent</code>.</p>"},{"location":"design/data-retrieval/#data-storage","title":"Data Storage","text":"<p>Our design will attempt to use pandas to extract the data dumps and then filter down the data sets to contain only relevant information. There are important points to identify as part of R&amp;D in this area.</p> <p>Warning - There be dragons!!!</p> <p>First, large data sets are a problem for various databases, pandas included. In our initial design we tried to push the limits of pandas by loading as much data inside the DataFrame except for a few useless columns. After about 3-4 quarters worth of data from over 7000 ticker symbols, the panda cried uncle with a glorified, but not so glorified:</p> <pre><code>tests/test_sec.py ss........                                                                                    [ 58%]\ntests/test_sec_network.py .s.Killed\n</code></pre> <p>The <code>Killed</code> message is a signal from the OS that you've successfully exhausted all the memory of the system and they're ending you unceremoniously with a <code>kill -9</code>. </p> <p>So what's next? Well we're still going to try and use pandas, just for the sake of trying to do a few things:</p> <ul> <li>Solve interesting algorithmic problems</li> <li>Keep our storage size small</li> <li>Use as much native python code as possible for simplifying usage and analysis for the end-user</li> <li>Avoid taking the easy way out by just throwing more memory and storage at the problem</li> </ul> <p>This means that we'll need to refactor the processing a bit so that we can pass a set of analytics to collect while looking at a particular stock ticker. This will allow us to scrape a very small subset of information about a company without unpacking these 50MB compressed archives (which can easily take 0.5 GB of storage per quarter uncompressed)</p> <p>Here is an example of the data scraped from AAPL for q after the refactoring.</p> <pre><code># Filter used in test\ndef filter_aapl() -&gt; Filter.Selectors:\nreturn Filter.Selectors(\nticker_filter={\"aapl\"},\nsec_filter=Filter.SecFilter(\ntags=[\"EntityCommonStockSharesOutstanding\"],\nyears=0,  # Just want the current\nlast_report=ReportDate(year=2023, quarter=1),\nonly_annual=False,\n),  # We want the 10-Q\n)\nThere are 67 records about apple (test_sec_network.py:55)\n2023-04-30 17:53:05 [   DEBUG]\n</code></pre> <p>Bug</p> <p>Note there's a bug in the filtering in this example. The <code>tags</code> field should have reduced this to one row, but it did not.</p> <pre><code>|                                                                                                                                                    | uom    |         value |   fy | fp   |\n|:---------------------------------------------------------------------------------------------------------------------------------------------------|:-------|--------------:|-----:|:-----|\n| ('0000320193-23-000006', 'EntityCommonStockSharesOutstanding', 320193)                                                                             | shares |   1.58219e+10 | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccountsPayableCurrent', 320193)                                                                                         | USD    |   5.7918e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccountsPayableCurrent', 320193)                                                                                         | USD    |   6.4115e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccountsReceivableNetCurrent', 320193)                                                                                   | USD    |   2.3752e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccountsReceivableNetCurrent', 320193)                                                                                   | USD    |   2.8184e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccumulatedDepreciationDepletionAndAmortizationPropertyPlantAndEquipment', 320193)                                       | USD    |   6.8044e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccumulatedDepreciationDepletionAndAmortizationPropertyPlantAndEquipment', 320193)                                       | USD    |   7.234e+10   | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccumulatedOtherComprehensiveIncomeLossNetOfTax', 320193)                                                                | USD    |  -1.2912e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AccumulatedOtherComprehensiveIncomeLossNetOfTax', 320193)                                                                | USD    |  -1.1109e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AllocatedShareBasedCompensationExpense', 320193)                                                                         | USD    |   2.905e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'AllocatedShareBasedCompensationExpense', 320193)                                                                         | USD    |   2.265e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'Assets', 320193)                                                                                                         | USD    |   3.52755e+11 | 2023 | Q1   |\n| ('0000320193-23-000006', 'Assets', 320193)                                                                                                         | USD    |   3.46747e+11 | 2023 | Q1   |\n| ('0000320193-23-000006', 'AssetsCurrent', 320193)                                                                                                  | USD    |   1.35405e+11 | 2023 | Q1   |\n| ('0000320193-23-000006', 'AssetsCurrent', 320193)                                                                                                  | USD    |   1.28777e+11 | 2023 | Q1   |\n| ('0000320193-23-000006', 'AssetsNoncurrent', 320193)                                                                                               | USD    |   2.1735e+11  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AssetsNoncurrent', 320193)                                                                                               | USD    |   2.1797e+11  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AvailableForSaleSecuritiesDebtMaturitiesRollingAfterYearTenFairValue', 320193)                                           | USD    |   1.7355e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AvailableForSaleSecuritiesDebtMaturitiesRollingYearSixThroughTenFairValue', 320193)                                      | USD    |   1.4243e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AvailableForSaleSecuritiesDebtMaturitiesRollingYearTwoThroughFiveFairValue', 320193)                                     | USD    |   8.2497e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'AvailableForSaleSecuritiesDebtMaturitiesSingleMaturityDate', 320193)                                                     | USD    |   1.14095e+11 | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashAndCashEquivalentsAtCarryingValue', 320193)                                                                          | USD    |   2.3646e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashAndCashEquivalentsAtCarryingValue', 320193)                                                                          | USD    |   2.0535e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalents', 320193)                                                  | USD    |   3.5929e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalents', 320193)                                                  | USD    |   3.863e+10   | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalents', 320193)                                                  | USD    |   2.4977e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalents', 320193)                                                  | USD    |   2.1974e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect', 320193) | USD    |   2.701e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect', 320193) | USD    |  -3.003e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommercialPaper', 320193)                                                                                                | USD    |   9.982e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommercialPaper', 320193)                                                                                                | USD    |   1.743e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommitmentsAndContingencies', 320193)                                                                                    | USD    | nan           | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommitmentsAndContingencies', 320193)                                                                                    | USD    | nan           | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockDividendsPerShareDeclared', 320193)                                                                           | USD    |   0.22        | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockDividendsPerShareDeclared', 320193)                                                                           | USD    |   0.23        | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockParOrStatedValuePerShare', 320193)                                                                            | USD    |   0           | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockParOrStatedValuePerShare', 320193)                                                                            | USD    |   0           | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockSharesAuthorized', 320193)                                                                                    | shares |   5.04e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockSharesAuthorized', 320193)                                                                                    | shares |   5.04e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockSharesIssued', 320193)                                                                                        | shares |   1.59434e+10 | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockSharesIssued', 320193)                                                                                        | shares |   1.58424e+10 | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockSharesOutstanding', 320193)                                                                                   | shares |   1.59434e+10 | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStockSharesOutstanding', 320193)                                                                                   | shares |   1.58424e+10 | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStocksIncludingAdditionalPaidInCapital', 320193)                                                                   | USD    |   6.4849e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CommonStocksIncludingAdditionalPaidInCapital', 320193)                                                                   | USD    |   6.6399e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'ComprehensiveIncomeNetOfTax', 320193)                                                                                    | USD    |   3.354e+10   | 2023 | Q1   |\n| ('0000320193-23-000006', 'ComprehensiveIncomeNetOfTax', 320193)                                                                                    | USD    |   2.8195e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'ContractWithCustomerLiability', 320193)                                                                                  | USD    |   1.24e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'ContractWithCustomerLiability', 320193)                                                                                  | USD    |   1.26e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'ContractWithCustomerLiabilityCurrent', 320193)                                                                           | USD    |   7.912e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'ContractWithCustomerLiabilityCurrent', 320193)                                                                           | USD    |   7.992e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'ContractWithCustomerLiabilityRevenueRecognized', 320193)                                                                 | USD    |   3e+09       | 2023 | Q1   |\n| ('0000320193-23-000006', 'ContractWithCustomerLiabilityRevenueRecognized', 320193)                                                                 | USD    |   3.4e+09     | 2023 | Q1   |\n| ('0000320193-23-000006', 'CostOfGoodsAndServicesSold', 320193)                                                                                     | USD    |   6.9702e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'CostOfGoodsAndServicesSold', 320193)                                                                                     | USD    |   6.6822e+10  | 2023 | Q1   |\n| ('0000320193-23-000006', 'DebtSecuritiesAvailableForSaleRestricted', 320193)                                                                       | USD    |   1.27e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'DebtSecuritiesAvailableForSaleRestricted', 320193)                                                                       | USD    |   1.36e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'DepreciationDepletionAndAmortization', 320193)                                                                           | USD    |   2.697e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'DepreciationDepletionAndAmortization', 320193)                                                                           | USD    |   2.916e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'DerivativeFairValueOfDerivativeNet', 320193)                                                                             | USD    |   4.12e+08    | 2023 | Q1   |\n| ('0000320193-23-000006', 'EarningsPerShareBasic', 320193)                                                                                          | USD    |   2.11        | 2023 | Q1   |\n| ('0000320193-23-000006', 'EarningsPerShareBasic', 320193)                                                                                          | USD    |   1.89        | 2023 | Q1   |\n| ('0000320193-23-000006', 'EarningsPerShareDiluted', 320193)                                                                                        | USD    |   2.1         | 2023 | Q1   |\n| ('0000320193-23-000006', 'EarningsPerShareDiluted', 320193)                                                                                        | USD    |   1.88        | 2023 | Q1   |\n| ('0000320193-23-000006', 'EmployeeServiceShareBasedCompensationNonvestedAwardsTotalCompensationCostNotYetRecognized', 320193)                      | USD    |   2.55e+10    | 2023 | Q1   |\n| ('0000320193-23-000006', 'EmployeeServiceShareBasedCompensationTaxBenefitFromCompensationExpense', 320193)                                         | USD    |   1.536e+09   | 2023 | Q1   |\n| ('0000320193-23-000006', 'EmployeeServiceShareBasedCompensationTaxBenefitFromCompensationExpense', 320193)                                         | USD    |   1.178e+09   | 2023 | Q1   |\n</code></pre>"},{"location":"design/reference/","title":"Reference Documents","text":"<p>Fundamental analysis, at its source, starts with having a good reliable data set.</p>","tags":["Data Sources"]},{"location":"design/reference/#data-sets","title":"Data Sets","text":"Provider Summary Current / Planned Usage SEC Financial Statement Data Sets SEC Edgar Daily Index SEC Edgar SEC API SEC Financial Data Sets SEC Company Tickers","tags":["Data Sources"]},{"location":"design/reference/#tools","title":"Tools","text":"Provider Name Usage Github openedgar Github yfinance Github sec-edgar Download appropriate reports","tags":["Data Sources"]},{"location":"design/report/","title":"Accessing the Report","text":"<p>The general concept is that the report could be accessed locally or remotely via cached results created from the report generation. Because companies are like battleships, fundamental analysis of short term data is unlikely to have much of an impact on long-term results so generating period reports in a static format keeps the access time \\(O(1)\\). </p>"},{"location":"design/report/#local-access","title":"Local Access","text":"<p>Local reports could be accessed or displayed as JSON or TEXT.</p>"},{"location":"design/report/#remote-access","title":"Remote Access","text":"<p>For the API specification, we could use Swagger to generate a specification that accesses the statically generated JSON reports via HTTP GET requests on a server hosting the reports. TBD</p> <p>Once the API specification is in place, we'll use Flutter to create web/mobile apps to access and display the data in a more user friendly format.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>src<ul> <li>stocktracer<ul> <li>analysis<ul> <li>annual_reports</li> <li>diluted_eps</li> <li>f_score</li> <li>stub</li> <li>tensorflow</li> </ul> </li> <li>cache</li> <li>cli</li> <li>collector<ul> <li>sec</li> </ul> </li> <li>filter</li> <li>interface</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/src/stocktracer/","title":"stocktracer","text":""},{"location":"reference/src/stocktracer/cache/","title":"cache","text":"<p>This module takes care of managing caching configuration.</p>"},{"location":"reference/src/stocktracer/cache/#src.stocktracer.cache.get_cache_dir","title":"<code>get_cache_dir()</code>","text":"<p>Get the cache directory used by stocktracer.</p> <p>Users can customize this directory on all systems using <code>STOCKTRACER_CACHE_DIR</code> environment variable. By default, the cache directory is the user cache directory under the stocktracer application.</p> <p>This result is immediately set to a constant <code>stocktracer.cache.CACHE_DIR</code> as to avoid repeated calls.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>path to the cache directory</p> Source code in <code>src/stocktracer/cache.py</code> <pre><code>@beartype\ndef get_cache_dir() -&gt; Path:\n\"\"\"Get the cache directory used by stocktracer.\n    Users can customize this directory on all systems using `STOCKTRACER_CACHE_DIR`\n    environment variable. By default, the cache directory is the user cache directory\n    under the stocktracer application.\n    This result is immediately set to a constant `stocktracer.cache.CACHE_DIR` as to avoid\n    repeated calls.\n    Returns:\n        Path: path to the cache directory\n    \"\"\"\ndefault_cache_dir = user_cache_dir(\"stocktracer\")\ncache_dir = Path(os.environ.get(\"STOCKTRACER_CACHE_DIR\", default_cache_dir))\nreturn cache_dir\n</code></pre>"},{"location":"reference/src/stocktracer/cache/#src.stocktracer.cache.update_modified_file_cache","title":"<code>update_modified_file_cache()</code>","text":"<p>Update the cache that keeps track of when files are modified.</p> Source code in <code>src/stocktracer/cache.py</code> <pre><code>def update_modified_file_cache() -&gt; None:\n\"\"\"Update the cache that keeps track of when files are modified.\"\"\"\nresults.set(\"sec_file_hash\", SEC_FILE_HASH)\nresults.close()\n</code></pre>"},{"location":"reference/src/stocktracer/cli/","title":"cli","text":"<p>This is the CLI class for stocktracer.</p>"},{"location":"reference/src/stocktracer/cli/#src.stocktracer.cli.Cli","title":"<code>Cli</code>","text":"<p>Tools for gathering resources, analyzing data, and publishing the results.</p> Source code in <code>src/stocktracer/cli.py</code> <pre><code>@beartype\nclass Cli:\n\"\"\"Tools for gathering resources, analyzing data, and publishing the results.\"\"\"\nreturn_results: bool = True\ndef analyze(  # pylint: disable=too-many-arguments\nself,\ntickers: Union[Sequence[str], str],\nanalysis_plugin: str = \"stocktracer.analysis.annual_reports\",\nfinal_year: int = ReportDate().year,\nfinal_quarter: int = ReportDate().quarter,\nreport_format: ReportFormat = \"txt\",\nreport_file: Optional[Path | str] = None,\n) -&gt; Optional[pd.DataFrame]:\n\"\"\"Perform stock analysis.\n        Args:\n            tickers (Union[Sequence[str], str]): tickers to include in the analysis\n            analysis_plugin (str): module to load for analysis\n            final_year (int): last year to consider for report collection\n            final_quarter (int): last quarter to consider for report collection\n            report_format (ReportFormat): Format of the report. Options include: csv, json, md (markdown)\n            report_file (Optional[Path | str]): Where to store the report. Required if report_format is specified.\n        Returns:\n            Optional[pd.DataFrame]: results of analysis\n        \"\"\"\nif report_file:\nreport_file = Path(report_file)\ntickers_set = set()\nif isinstance(tickers, str):\ntickers_set.add(tickers)\nelse:\ntickers_set = set()\nfor t in tickers:\ntickers_set.add(t)\n# prep for caching\ntickers_list = list(tickers_set)\ntickers_list.sort()\nresults, analysis_module = self._get_result(\ntickers=tickers_list,\nanalysis_plugin=analysis_plugin,\nfinal_year=final_year,\nfinal_quarter=final_quarter,\n)\nself._generate_report(report_format, report_file, results)\nif analysis_module.under_development:\nwarnings.warn(\n\"This analysis module is under development and may be incorrect, incomplete, or may change.\"\n)\nif self.return_results:\nreturn results\nreturn None\n@classmethod\ndef _generate_report(\ncls,\nreport_format: ReportFormat,\nreport_file: Path | io.StringIO | None,\nresults: pd.DataFrame,\n):\nif report_file is None:\nreport_file = io.StringIO()\nresults = results.transpose()\nmatch report_format.lower():\ncase \"csv\":\nresults.to_csv(report_file)\ncase \"md\":\nresults.to_markdown(report_file)\ncase \"json\":\nresults.to_json(report_file)\ncase \"txt\":\nresults.to_string(report_file)\nif isinstance(report_file, io.StringIO):\nprint(report_file.getvalue())\n@cache.results.memoize(typed=True, expire=60 * 60 * 24 * 7, tag=\"results\")\ndef _get_result(\nself,\ntickers: list[str],\nanalysis_plugin: str,\nfinal_year: int,\nfinal_quarter: int,\n) -&gt; Tuple[Optional[pd.DataFrame], AnalysisInterface]:\n\"\"\"Gets the results.\n        Args:\n            tickers (list[str]): _description_\n            analysis_plugin (str): _description_\n            final_year (int): _description_\n            final_quarter (int): _description_\n        Raises:\n            LookupError: no analysis results found\n        Returns:\n            Tuple[Optional[pd.DataFrame], AnalysisInterface]: _description_\n        \"\"\"\nanalysis_module: AnalysisInterface = get_analysis_instance(\nanalysis_plugin,\nCliOptions(\ntickers=tickers,\nfinal_report=ReportDate(year=final_year, quarter=final_quarter),\n),\n)\n# Call analysis plugin\nresults = None\nresults = analysis_module.analyze()\nif results is None:\nraise LookupError(\"No analysis results available!\")\nreturn results, analysis_module\n</code></pre>"},{"location":"reference/src/stocktracer/cli/#src.stocktracer.cli.Cli.analyze","title":"<code>analyze(tickers, analysis_plugin='stocktracer.analysis.annual_reports', final_year=ReportDate().year, final_quarter=ReportDate().quarter, report_format='txt', report_file=None)</code>","text":"<p>Perform stock analysis.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>Union[Sequence[str], str]</code> <p>tickers to include in the analysis</p> required <code>analysis_plugin</code> <code>str</code> <p>module to load for analysis</p> <code>'stocktracer.analysis.annual_reports'</code> <code>final_year</code> <code>int</code> <p>last year to consider for report collection</p> <code>ReportDate().year</code> <code>final_quarter</code> <code>int</code> <p>last quarter to consider for report collection</p> <code>ReportDate().quarter</code> <code>report_format</code> <code>ReportFormat</code> <p>Format of the report. Options include: csv, json, md (markdown)</p> <code>'txt'</code> <code>report_file</code> <code>Optional[Path | str]</code> <p>Where to store the report. Required if report_format is specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[pd.DataFrame]</code> <p>Optional[pd.DataFrame]: results of analysis</p> Source code in <code>src/stocktracer/cli.py</code> <pre><code>def analyze(  # pylint: disable=too-many-arguments\nself,\ntickers: Union[Sequence[str], str],\nanalysis_plugin: str = \"stocktracer.analysis.annual_reports\",\nfinal_year: int = ReportDate().year,\nfinal_quarter: int = ReportDate().quarter,\nreport_format: ReportFormat = \"txt\",\nreport_file: Optional[Path | str] = None,\n) -&gt; Optional[pd.DataFrame]:\n\"\"\"Perform stock analysis.\n    Args:\n        tickers (Union[Sequence[str], str]): tickers to include in the analysis\n        analysis_plugin (str): module to load for analysis\n        final_year (int): last year to consider for report collection\n        final_quarter (int): last quarter to consider for report collection\n        report_format (ReportFormat): Format of the report. Options include: csv, json, md (markdown)\n        report_file (Optional[Path | str]): Where to store the report. Required if report_format is specified.\n    Returns:\n        Optional[pd.DataFrame]: results of analysis\n    \"\"\"\nif report_file:\nreport_file = Path(report_file)\ntickers_set = set()\nif isinstance(tickers, str):\ntickers_set.add(tickers)\nelse:\ntickers_set = set()\nfor t in tickers:\ntickers_set.add(t)\n# prep for caching\ntickers_list = list(tickers_set)\ntickers_list.sort()\nresults, analysis_module = self._get_result(\ntickers=tickers_list,\nanalysis_plugin=analysis_plugin,\nfinal_year=final_year,\nfinal_quarter=final_quarter,\n)\nself._generate_report(report_format, report_file, results)\nif analysis_module.under_development:\nwarnings.warn(\n\"This analysis module is under development and may be incorrect, incomplete, or may change.\"\n)\nif self.return_results:\nreturn results\nreturn None\n</code></pre>"},{"location":"reference/src/stocktracer/cli/#src.stocktracer.cli.get_analysis_instance","title":"<code>get_analysis_instance(module_name, options)</code>","text":"<p>Dynamically import and load the Analysis class from a module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>full name of the module. For example, \"my.module\"</p> required <code>options</code> <code>CliOptions</code> <p>options provided from the CLI</p> required <p>Returns:</p> Name Type Description <code>AnalysisInterface</code> <code>AnalysisInterface</code> <p>analysis instance</p> Source code in <code>src/stocktracer/cli.py</code> <pre><code>@beartype\ndef get_analysis_instance(module_name: str, options: CliOptions) -&gt; AnalysisInterface:\n\"\"\"Dynamically import and load the Analysis class from a module.\n    Args:\n        module_name (str): full name of the module. For example, \"my.module\"\n        options (CliOptions): options provided from the CLI\n    Returns:\n        AnalysisInterface: analysis instance\n    \"\"\"\nmodule = importlib.import_module(module_name)\nclass_ = getattr(module, \"Analysis\")\ninstance = class_(options)\nassert isinstance(instance, AnalysisInterface)\nreturn instance\n</code></pre>"},{"location":"reference/src/stocktracer/filter/","title":"filter","text":"<p>Filter Interface.</p> <p>This may be removed or deprecated in the future. TBD.</p>"},{"location":"reference/src/stocktracer/filter/#src.stocktracer.filter.Selectors","title":"<code>Selectors</code>  <code>dataclass</code>","text":"<p>Selectors provide an aggregation point for a number of built-in filter mechanics.</p> <p>The original intent for this was to provide a bag to throw a bunch of filters in. However, analysis modules somewhat replace this concept by giving finer grained control over what filters get applied. This may go away in the future pending a determination whether or not the class is needed.</p> Source code in <code>src/stocktracer/filter.py</code> <pre><code>@beartype\n@dataclass(frozen=True)\nclass Selectors:\n\"\"\"Selectors provide an aggregation point for a number of built-in filter mechanics.\n    The original intent for this was to provide a bag to throw a bunch of filters in. However,\n    analysis modules somewhat replace this concept by giving finer grained control over what\n    filters get applied. This may go away in the future pending a determination whether or not\n    the class is needed.\n    \"\"\"\nticker_filter: list[str]\nsec_filter: SecFilter\n</code></pre>"},{"location":"reference/src/stocktracer/interface/","title":"interface","text":"<p>Interfaces for the StockTracer Module.</p>"},{"location":"reference/src/stocktracer/interface/#src.stocktracer.interface.Analysis","title":"<code>Analysis</code>","text":"<p>Base class for all analysis techniques.</p> Source code in <code>src/stocktracer/interface.py</code> <pre><code>@beartype\nclass Analysis(metaclass=abc.ABCMeta):\n\"\"\"Base class for all analysis techniques.\"\"\"\ndef __init__(self, options: Options) -&gt; None:\nself.options = options\nassert self.options is not None\n@abc.abstractmethod\ndef analyze(self) -&gt; Optional[DataFrame]:\n\"\"\"Perform financial analysis.\n        Returns:\n            Optional[DataFrame]: results of analysis\n        \"\"\"\nunder_development: bool = False\n</code></pre>"},{"location":"reference/src/stocktracer/interface/#src.stocktracer.interface.Analysis.analyze","title":"<code>analyze()</code>  <code>abstractmethod</code>","text":"<p>Perform financial analysis.</p> <p>Returns:</p> Type Description <code>Optional[DataFrame]</code> <p>Optional[DataFrame]: results of analysis</p> Source code in <code>src/stocktracer/interface.py</code> <pre><code>@abc.abstractmethod\ndef analyze(self) -&gt; Optional[DataFrame]:\n\"\"\"Perform financial analysis.\n    Returns:\n        Optional[DataFrame]: results of analysis\n    \"\"\"\n</code></pre>"},{"location":"reference/src/stocktracer/interface/#src.stocktracer.interface.Options","title":"<code>Options</code>  <code>dataclass</code>","text":"<p>Command Line Options.</p> Source code in <code>src/stocktracer/interface.py</code> <pre><code>@beartype\n@dataclass(frozen=True)\nclass Options:\n\"\"\"Command Line Options.\"\"\"\ntickers: list[str]\nfinal_report: ReportDate = ReportDate()\ndef __post_init__(self):\nself.tickers.sort()\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/","title":"analysis","text":"<p>All the build-in modules are organized here.</p>"},{"location":"reference/src/stocktracer/analysis/annual_reports/","title":"annual_reports","text":"<p>Download and retrieves annual reports for the specified stock tickers.</p>"},{"location":"reference/src/stocktracer/analysis/annual_reports/#src.stocktracer.analysis.annual_reports.Analysis","title":"<code>Analysis</code>","text":"<p>         Bases: <code>AnalysisInterface</code></p> <p>Class for collecting and processing annual report data.</p> Source code in <code>src/stocktracer/analysis/annual_reports.py</code> <pre><code>@beartype\nclass Analysis(AnalysisInterface):\n\"\"\"Class for collecting and processing annual report data.\"\"\"\nunder_development = True\ndef analyze(self) -&gt; Optional[pd.DataFrame]:\n# By omitting the tags, we'll collect all tags for securities\nsec_filter = Sec.Filter(\n# tags=[\"EarningsPerShareDiluted\"],\nyears=1,  # Over the past 1 years\nlast_report=self.options.final_report,\nonly_annual=True,  # We only want the 10-K\n)\n# Create an SEC Data Source\ntable = create_normalized_sec_table(sec_filter, self.options.tickers, False)\nreturn table.data\n# Reuse documentation from parent\nanalyze.__doc__ = AnalysisInterface.analyze.__doc__\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/annual_reports/#src.stocktracer.analysis.annual_reports.create_normalized_sec_table","title":"<code>create_normalized_sec_table(sec_filter, tickers, normalize=True)</code>","text":"<p>Create a normalized SEC table with all NA values removed.</p> <p>Parameters:</p> Name Type Description Default <code>sec_filter</code> <code>Sec.Filter</code> <p>filter to use for grabbing results</p> required <code>tickers</code> <code>list[str]</code> <p>tickers to retrieve</p> required <code>normalize</code> <code>bool</code> <p>Remove all columns that contain at least one NA value</p> <code>True</code> <p>Returns:</p> Type Description <code>Sec.Results.Table</code> <p>Sec.Results.Table: An SEC table with normalized results</p> Source code in <code>src/stocktracer/analysis/annual_reports.py</code> <pre><code>def create_normalized_sec_table(\nsec_filter: Sec.Filter, tickers: list[str], normalize: bool = True\n) -&gt; Sec.Results.Table:\n\"\"\"Create a normalized SEC table with all NA values removed.\n    Args:\n        sec_filter (Sec.Filter): filter to use for grabbing results\n        tickers (list[str]): tickers to retrieve\n        normalize (bool): Remove all columns that contain at least one NA value\n    Returns:\n        Sec.Results.Table: An SEC table with normalized results\n    \"\"\"\n# prep for caching\ntickers.sort()\nresults = Sec.filter_data(tickers=tickers, sec_filter=sec_filter)\ntable = results.select()\n# If you prefer to see columns that are not universal across all stocks, comment this out\nif normalize:\ntable.normalize()\nreturn table\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/diluted_eps/","title":"diluted_eps","text":"<p>This analysis module determines the trend of EPS over the course of the past 5 years.</p>"},{"location":"reference/src/stocktracer/analysis/diluted_eps/#src.stocktracer.analysis.diluted_eps.Analysis","title":"<code>Analysis</code>","text":"<p>         Bases: <code>AnalysisInterface</code></p> <p>Class that calculates the EPS slope.</p> Source code in <code>src/stocktracer/analysis/diluted_eps.py</code> <pre><code>@beartype\nclass Analysis(AnalysisInterface):\n\"\"\"Class that calculates the EPS slope.\"\"\"\nunder_development = True\nyears_of_analysis = 5\ndef analyze(self) -&gt; Optional[pd.DataFrame]:\n# Create the filter we'll use to scrape the results\nsec_filter = Sec.Filter(\ntags=[\"EarningsPerShareDiluted\"],\nyears=self.years_of_analysis,\nlast_report=self.options.final_report,\nonly_annual=True,  # We only want the 10-K\n)\n# This is an expensive operation\nresults = Sec.filter_data(tickers=self.options.tickers, sec_filter=sec_filter)\nreturn results.select(\"slope\").data\n# Reuse documentation from parent\nanalyze.__doc__ = AnalysisInterface.analyze.__doc__\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/f_score/","title":"f_score","text":"<p>Piotroski F-score is a number between 0 and 9 which is used to assess strength of company's financial position.</p>"},{"location":"reference/src/stocktracer/analysis/f_score/#src.stocktracer.analysis.f_score.Analysis","title":"<code>Analysis</code>","text":"<p>         Bases: <code>AnalysisInterface</code></p> <p>The score is used by financial investors in order to find the best value stocks (nine being the best). The score is named after Stanford accounting professor Joseph Piotroski.</p>"},{"location":"reference/src/stocktracer/analysis/f_score/#src.stocktracer.analysis.f_score.Analysis--calculation-procedure","title":"Calculation procedure","text":"<p>The score is calculated based on 9 criteria divided into 3 groups.[2]</p> <ul> <li>Profitability<ul> <li>Return on Assets (ROA) (1 point if it is positive in the current year, 0 otherwise);</li> <li>Operating Cash Flow (1 point if it is positive in the current year, 0 otherwise);</li> <li>Change in Return of Assets (ROA) (1 point if ROA is higher in the current year compared to the previous one, 0 otherwise);</li> <li>Accruals (1 point if Operating Cash Flow/Total Assets is higher than ROA in the current year, 0 otherwise);</li> </ul> </li> <li>Leverage, Liquidity and Source of Funds<ul> <li>Change in Leverage (long-term) ratio (1 point if the ratio is lower this year compared to the previous one, 0 otherwise);</li> <li>Change in Current ratio (1 point if it is higher in the current year compared to the previous one, 0 otherwise);</li> <li>Change in the number of shares (1 point if no new shares were issued during the last year);</li> </ul> </li> <li>Operating Efficiency<ul> <li>Change in Gross Margin (1 point if it is higher in the current year compared to the previous one, 0 otherwise);</li> <li>Change in Asset Turnover ratio (1 point if it is higher in the current year compared to the previous one, 0 otherwise);</li> </ul> </li> </ul> <p>Some adjustments that were done in calculation of the required financial ratios are discussed in the original paper.[2]</p> <p>The score is calculated based on the data from financial statement of a company. A company gets 1 point for each met criterion. Summing up of all achieved points gives Piotroski F-score (number between 0 and 9).</p> Source code in <code>src/stocktracer/analysis/f_score.py</code> <pre><code>@beartype\nclass Analysis(AnalysisInterface):\n\"\"\"\n    The score is used by financial investors in order to find the best value\n    stocks (nine being the best). The score is named after Stanford accounting professor Joseph Piotroski.\n    Calculation procedure\n    =====================\n    The score is calculated based on 9 criteria divided into 3 groups.[2]\n    - Profitability\n        - Return on Assets (ROA) (1 point if it is positive in the current year, 0 otherwise);\n        - Operating Cash Flow (1 point if it is positive in the current year, 0 otherwise);\n        - Change in Return of Assets (ROA) (1 point if ROA is higher in the current year compared to the previous one, 0 otherwise);\n        - Accruals (1 point if Operating Cash Flow/Total Assets is higher than ROA in the current year, 0 otherwise);\n    - Leverage, Liquidity and Source of Funds\n        - Change in Leverage (long-term) ratio (1 point if the ratio is lower this year compared to the previous one, 0 otherwise);\n        - Change in Current ratio (1 point if it is higher in the current year compared to the previous one, 0 otherwise);\n        - Change in the number of shares (1 point if no new shares were issued during the last year);\n    - Operating Efficiency\n        - Change in Gross Margin (1 point if it is higher in the current year compared to the previous one, 0 otherwise);\n        - Change in Asset Turnover ratio (1 point if it is higher in the current year compared to the previous one, 0 otherwise);\n    Some adjustments that were done in calculation of the required financial ratios are discussed in the original paper.[2]\n    The score is calculated based on the data from financial statement of a company. A company gets 1 point for each met criterion. Summing up of all achieved points gives Piotroski F-score (number between 0 and 9).\n    \"\"\"\nunder_development = True\nyears_of_analysis = 2\ndef analyze(self) -&gt; Optional[pd.DataFrame]:\n# Create the filter to scrape the data we need for processing\nsec_filter = Sec.Filter(\ntags=[\n\"EarningsPerShareDiluted\",\n\"CommonStockSharesIssued\",\n\"AssetsCurrent\",\n\"LiabilitiesCurrent\",\n\"Assets\",\n\"OperatingIncomeLoss\",\n\"NetCashProvidedByUsedInOperatingActivities\",\n],\nyears=self.years_of_analysis,\nlast_report=self.options.final_report,\nonly_annual=True,  # We only want the 10-K\n)\ntable = create_normalized_sec_table(sec_filter, self.options.tickers, False)\ntable.data.fillna(0, inplace=True)\nassert (\nself.options.final_report.year + 1\nnot in table.data.index.get_level_values(1)\n)\nlogger.debug(f\"filtered_data:\\n{table.data}\")\nmax_year = int(table.data.index.get_level_values(\"fy\").max())\n# Do calculations\ntable.calculate_return_on_assets(\"ROA\")\ntable.calculate_net_income(\"net-income\")\ntable.calculate_delta(column_name=\"delta-ROA\", delta_of=\"ROA\")\ntable.calculate_debt_to_assets(\"debt-to-assets\")\ntable.calculate_current_ratio(\"current-ratio\")\n# fscore = pd.DataFrame(index=table.data.index)\n# logger.debug(f\"\\n{fscore}\")\nf_score_tags = []\n# - Profitability\n#     - Return on Assets (ROA) (1 point if it is positive in the current year, 0 otherwise);\ntable.data[\"ROA&gt;0\"] = (table.data[\"ROA\"] &gt; 0).astype(int)\nf_score_tags.append(\"ROA&gt;0\")\n# TODO: select last year by ROA and assign a 1 if it's positive\n# logger.debug(f\"\\n{fscore}\")\n#     - Operating Cash Flow (1 point if it is positive in the current year, 0 otherwise);\ntable.data[\"NetIncome&gt;0\"] = (table.data[\"net-income\"] &gt; 0).astype(int)\nf_score_tags.append(\"NetIncome&gt;0\")\n#     - Change in Return of Assets (ROA) (1 point if ROA is higher in the current year compared to the previous one, 0 otherwise);\ntable.data[\"delta-ROA&gt;0\"] = (table.data[\"delta-ROA\"] &gt; 0).astype(int)\nf_score_tags.append(\"delta-ROA&gt;0\")\nlogger.debug(f\"ROA:\\n{table.data['ROA']}\")\nlogger.debug(f\"delta ROA:\\n{table.data['delta-ROA']}\")\n#     - Accruals (1 point if Operating Cash Flow/Total Assets is higher than ROA in the current year, 0 otherwise);\ntable.data[\"accruals\"] = (\ntable.data[\"NetCashProvidedByUsedInOperatingActivities\"]\n/ table.data[\"Assets\"]\n)\ntable.data[\"CF/Total-Assets&gt;ROA\"] = (\ntable.data[\"accruals\"] &gt; table.data[\"ROA\"]\n).astype(int)\nf_score_tags.append(\"CF/Total-Assets&gt;ROA\")\nlogger.debug(f\"accruals:\\n{table.data['accruals']}\")\nlogger.debug(f\"CF/Total-Assets&gt;ROA:\\n{table.data['CF/Total-Assets&gt;ROA']}\")\n# - Leverage, Liquidity and Source of Funds\n#     - Change in Leverage (long-term) ratio (1 point if the ratio is lower this year compared to the previous one, 0 otherwise);\ntable.calculate_delta(\"debt-to-assets-delta\", delta_of=\"debt-to-assets\")\ntable.data[\"debt-to-assets&lt;last-year\"] = (\ntable.data[\"debt-to-assets-delta\"] &lt; 0\n).astype(int)\nf_score_tags.append(\"debt-to-assets&lt;last-year\")\nlogger.debug(f\"debt-to-assets-delta:\\n{table.data['debt-to-assets-delta']}\")\nlogger.debug(\nf\"debt-to-assets&lt;last-year:\\n{table.data['debt-to-assets&lt;last-year']}\"\n)\n#     - Change in Current ratio (1 point if it is higher in the current year compared to the previous one, 0 otherwise);\ntable.calculate_delta(\"current-ratio-delta\", delta_of=\"current-ratio\")\ntable.data[\"current-ratio&gt;last-year\"] = (\ntable.data[\"current-ratio-delta\"] &gt; 0\n).astype(int)\nf_score_tags.append(\"current-ratio&gt;last-year\")\nlogger.debug(f\"current-ratio-delta:\\n{table.data['current-ratio-delta']}\")\nlogger.debug(\nf\"current-ratio&gt;last-year:\\n{table.data['current-ratio&gt;last-year']}\"\n)\n#     - Change in the number of shares (1 point if no new shares were issued during the last year);\ntable.data[\"shares-issued==0\"] = (\ntable.data[\"CommonStockSharesIssued\"] == 0\n).astype(int)\nf_score_tags.append(\"shares-issued==0\")\n# - Operating Efficiency\n#     - Change in Gross Margin (1 point if it is higher in the current year compared to the previous one, 0 otherwise);\n#     - Change in Asset Turnover ratio (1 point if it is higher in the current year compared to the previous one, 0 otherwise);\nreturn table.slice(year=max_year, tags=f_score_tags)\n# Reuse documentation from parent\nanalyze.__doc__ = AnalysisInterface.analyze.__doc__\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/stub/","title":"stub","text":"<p>This stub serves an example for module developers.</p>"},{"location":"reference/src/stocktracer/analysis/stub/#src.stocktracer.analysis.stub.Analysis","title":"<code>Analysis</code>","text":"<p>         Bases: <code>AnalysisInterface</code></p> <p>Stub for analyzing the report.</p> Source code in <code>src/stocktracer/analysis/stub.py</code> <pre><code>@beartype\nclass Analysis(AnalysisInterface):\n\"\"\"Stub for analyzing the report.\"\"\"\ndef analyze(self) -&gt; Optional[pd.DataFrame]:\n\"\"\"\n        As a stub, this does nothing\n        Returns:\n            Optional[pd.DataFrame]: Always None, since the stub doesn't analyze anything.\n        \"\"\"\nprint(\n\"This is where we would start to process information, but we're not right now\"\n)\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/stub/#src.stocktracer.analysis.stub.Analysis.analyze","title":"<code>analyze()</code>","text":"<p>As a stub, this does nothing</p> <p>Returns:</p> Type Description <code>Optional[pd.DataFrame]</code> <p>Optional[pd.DataFrame]: Always None, since the stub doesn't analyze anything.</p> Source code in <code>src/stocktracer/analysis/stub.py</code> <pre><code>def analyze(self) -&gt; Optional[pd.DataFrame]:\n\"\"\"\n    As a stub, this does nothing\n    Returns:\n        Optional[pd.DataFrame]: Always None, since the stub doesn't analyze anything.\n    \"\"\"\nprint(\n\"This is where we would start to process information, but we're not right now\"\n)\n</code></pre>"},{"location":"reference/src/stocktracer/analysis/tensorflow/","title":"tensorflow","text":"<p>Use tensorflow to perform automated analysis on stock tickers.</p>"},{"location":"reference/src/stocktracer/analysis/tensorflow/#src.stocktracer.analysis.tensorflow.Analysis","title":"<code>Analysis</code>","text":"<p>         Bases: <code>AnalysisInterface</code></p> <p>Class for collecting and processing annual report data.</p> Source code in <code>src/stocktracer/analysis/tensorflow.py</code> <pre><code>@beartype\nclass Analysis(AnalysisInterface):\n\"\"\"Class for collecting and processing annual report data.\"\"\"\nunder_development = True\ndef analyze(self) -&gt; Optional[pd.DataFrame]:\n# Build a training set involving good companies\nsec_filter = SecFilter(\ntags=[\n\"EarningsPerShareDiluted\",\n\"CommonStockSharesIssued\",\n\"AssetsCurrent\",\n\"LiabilitiesCurrent\",\n\"Assets\",\n\"OperatingIncomeLoss\",\n\"NetCashProvidedByUsedInOperatingActivities\",\n],\nyears=5,  # Over the past 5 years\nlast_report=self.options.final_report,\nonly_annual=True,  # We only want the 10-K\n)\ngood_tickers = set()\ngood_tickers.add(\"aapl\")\ngood_tickers.add(\"msft\")\ngood_tickers.add(\"goog\")\ngood_tickers.add(\"hd\")\ngood_tickers.add(\"acn\")\ngood_tickers.add(\"nvda\")\nbad_tickers = set()\nbad_tickers.add(\"wdc\")\nbad_tickers.add(\"nclh\")\nbad_tickers.add(\"grpn\")\nbad_tickers.add(\"capr\")\ncombined_tickers = list(\ngood_tickers.union(self.options.tickers).union(bad_tickers)\n)\n# Create an SEC Data Source\ntable = create_normalized_sec_table(sec_filter, combined_tickers, False)\ntable.calculate_return_on_assets(\"ROA\")\ntable.calculate_net_income(\"net_income\")\ntable.calculate_delta(column_name=\"delta_ROA\", delta_of=\"ROA\")\ntable.calculate_debt_to_assets(\"debt_to_assets\")\ntable.calculate_current_ratio(\"current_ratio\")\ntable.data[\"good_stock\"] = False\nfor t in good_tickers:\ntable.data.loc[t.upper(), [\"good_stock\"]] = True\ntable.data.fillna(0, inplace=True)\n# Select Training Stocks\ntrain_df = table.slice(ticker=list(good_tickers.union(bad_tickers)))\nlogging.debug(\nf\"there are {train_df['good_stock'].sum()} good stocks in the training set\"\n)\nlogging.debug(f\"training_data:\\n{train_df.to_string()}\")\n# Select Assessment Stocks\ntest_df = table.slice(\nticker=list(good_tickers.difference(self.options.tickers))\n)\ntrain_ds = tfdf.keras.pd_dataframe_to_tf_dataset(train_df, label=\"good_stock\")\ntest_ds = tfdf.keras.pd_dataframe_to_tf_dataset(test_df, label=\"good_stock\")\n# Train a Random Forest model.\nmodel = tfdf.keras.RandomForestModel()\nmodel.fit(train_ds)\n# Summary of the model structure.\nmodel.summary()\n# Evaluate the model.\nmodel.evaluate(test_ds)\n# Export the model to a SavedModel.\nmodel.save(str(cache.CACHE_DIR / \"tf-model\"))\nreturn pd.DataFrame()\n# Reuse documentation from parent\nanalyze.__doc__ = AnalysisInterface.analyze.__doc__\n</code></pre>"},{"location":"reference/src/stocktracer/collector/","title":"collector","text":"<p>Modules for processing and ingesting data from outside sources.</p>"},{"location":"reference/src/stocktracer/collector/sec/","title":"sec","text":"<p>This data source grabs information from quarterly SEC data archives.</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DataSetCollector","title":"<code>DataSetCollector</code>","text":"<p>Take care of downloading all the data sets and aggregate them into a single structure.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\nclass DataSetCollector:\n\"\"\"Take care of downloading all the data sets and aggregate them into a single structure.\"\"\"\ndef __init__(self, download_manager: DownloadManager):\nself.download_manager = download_manager\ndef get_data(self, sec_filter: Filter, ciks: frozenset[int]) -&gt; Results:\n\"\"\"Collect data based on the provided filter.\n        Args:\n            sec_filter (Filter): SEC specific filter of how to filter the results\n            ciks (frozenset[int]): CIK values to filter the datasets on\n        Raises:\n            ImportError: when a download for a quarterly report fails\n            LookupError: when the filter returned no matches\n        Returns:\n            Results: filtered data results\n        \"\"\"\ndata_frame = None\nreport_dates = sec_filter.required_reports\nlogger.info(f\"Creating Unified Data record for these reports: {report_dates}\")\nwith alive_bar(\n# total=len(report_dates) * 2,\ntheme=\"smooth\",\n# stats=False,\ntitle=\"Records Retrieved\",\nfile=sys.stderr,\ncalibrate=5_000,\ndual_line=True,\n) as status_bar:\nfor report_date in report_dates:\nstatus_bar.text(f\"Downloading report {report_date}...\")\nreader = self.download_manager.get_quarterly_report(report_date)\nif reader is None:\nraise ImportError(f\"missing quarterly report for {report_date}\")\nstatus_bar.text(f\"Processing report {report_date}...\")\ndata = reader.process_zip(sec_filter, ciks)\nif data is None:\n# Note, when searching for annual reports, this will generally occur 1/4 times\n# if we're only searching for one stock's tags\nlogger.debug(\nf\"{report_date} did not have any matches for the provided filter\"\n)\nlogger.debug(f\"{sec_filter}\")\ncontinue\nif data_frame is not None:\nlogger.debug(f\"record count: {len(data_frame)}\")\nlogger.debug(f\"new record count: {len(data)}\")\ndata_frame = DataSetReader.append(data_frame, data)\nrecord_count = len(data_frame)\nstatus_bar(record_count)  # pylint: disable=not-callable\nlogger.info(f\"There are now {record_count} filtered records\")\nlogger.info(f\"Created Unified Data record for these reports: {report_dates}\")\nif data_frame is None:\nraise LookupError(\"No data matching the filter was retrieved\")\n# Now add an index for ticker values to pair with the cik\n# logger.debug(f\"filtered_df_before_merge:\\n{data_frame.to_csv()}\")\ndata_frame = data_frame.reset_index().merge(\nright=self.download_manager.ticker_reader.map_of_cik_to_ticker,\nhow=\"inner\",\nleft_on=\"cik\",\nright_on=[\"cik_str\"],\n)\n# Columns at this point look like this\n#  ,adsh,tag,cik,ddate,uom,value,period,fy,fp,cik_str,ticker,title\n# 0,0000097745-23-000008,EarningsPerShareDiluted,97745,2022-12-31,USD,17.63,2022-12-31,2022.0,FY,97745,TMO,THERMO FISHER SCIENTIFIC INC.\n# 1,0000097745-23-000008,EarningsPerShareDiluted,97745,2020-12-31,USD,15.96,2022-12-31,2022.0,FY,97745,TMO,THERMO FISHER SCIENTIFIC INC.\n# 2,0000097745-23-000008,EarningsPerShareDiluted,97745,2021-12-31,USD,19.46,2022-12-31,2022.0,FY,97745,TMO,THERMO FISHER SCIENTIFIC INC..\nreturn Results(\ndata_frame.drop(columns=[\"cik_str\", \"adsh\", \"cik\"]).set_index(\n[\"ticker\", \"tag\", \"fy\", \"fp\"]\n)\n)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DataSetCollector.get_data","title":"<code>get_data(sec_filter, ciks)</code>","text":"<p>Collect data based on the provided filter.</p> <p>Parameters:</p> Name Type Description Default <code>sec_filter</code> <code>Filter</code> <p>SEC specific filter of how to filter the results</p> required <code>ciks</code> <code>frozenset[int]</code> <p>CIK values to filter the datasets on</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>when a download for a quarterly report fails</p> <code>LookupError</code> <p>when the filter returned no matches</p> <p>Returns:</p> Name Type Description <code>Results</code> <code>Results</code> <p>filtered data results</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def get_data(self, sec_filter: Filter, ciks: frozenset[int]) -&gt; Results:\n\"\"\"Collect data based on the provided filter.\n    Args:\n        sec_filter (Filter): SEC specific filter of how to filter the results\n        ciks (frozenset[int]): CIK values to filter the datasets on\n    Raises:\n        ImportError: when a download for a quarterly report fails\n        LookupError: when the filter returned no matches\n    Returns:\n        Results: filtered data results\n    \"\"\"\ndata_frame = None\nreport_dates = sec_filter.required_reports\nlogger.info(f\"Creating Unified Data record for these reports: {report_dates}\")\nwith alive_bar(\n# total=len(report_dates) * 2,\ntheme=\"smooth\",\n# stats=False,\ntitle=\"Records Retrieved\",\nfile=sys.stderr,\ncalibrate=5_000,\ndual_line=True,\n) as status_bar:\nfor report_date in report_dates:\nstatus_bar.text(f\"Downloading report {report_date}...\")\nreader = self.download_manager.get_quarterly_report(report_date)\nif reader is None:\nraise ImportError(f\"missing quarterly report for {report_date}\")\nstatus_bar.text(f\"Processing report {report_date}...\")\ndata = reader.process_zip(sec_filter, ciks)\nif data is None:\n# Note, when searching for annual reports, this will generally occur 1/4 times\n# if we're only searching for one stock's tags\nlogger.debug(\nf\"{report_date} did not have any matches for the provided filter\"\n)\nlogger.debug(f\"{sec_filter}\")\ncontinue\nif data_frame is not None:\nlogger.debug(f\"record count: {len(data_frame)}\")\nlogger.debug(f\"new record count: {len(data)}\")\ndata_frame = DataSetReader.append(data_frame, data)\nrecord_count = len(data_frame)\nstatus_bar(record_count)  # pylint: disable=not-callable\nlogger.info(f\"There are now {record_count} filtered records\")\nlogger.info(f\"Created Unified Data record for these reports: {report_dates}\")\nif data_frame is None:\nraise LookupError(\"No data matching the filter was retrieved\")\n# Now add an index for ticker values to pair with the cik\n# logger.debug(f\"filtered_df_before_merge:\\n{data_frame.to_csv()}\")\ndata_frame = data_frame.reset_index().merge(\nright=self.download_manager.ticker_reader.map_of_cik_to_ticker,\nhow=\"inner\",\nleft_on=\"cik\",\nright_on=[\"cik_str\"],\n)\n# Columns at this point look like this\n#  ,adsh,tag,cik,ddate,uom,value,period,fy,fp,cik_str,ticker,title\n# 0,0000097745-23-000008,EarningsPerShareDiluted,97745,2022-12-31,USD,17.63,2022-12-31,2022.0,FY,97745,TMO,THERMO FISHER SCIENTIFIC INC.\n# 1,0000097745-23-000008,EarningsPerShareDiluted,97745,2020-12-31,USD,15.96,2022-12-31,2022.0,FY,97745,TMO,THERMO FISHER SCIENTIFIC INC.\n# 2,0000097745-23-000008,EarningsPerShareDiluted,97745,2021-12-31,USD,19.46,2022-12-31,2022.0,FY,97745,TMO,THERMO FISHER SCIENTIFIC INC..\nreturn Results(\ndata_frame.drop(columns=[\"cik_str\", \"adsh\", \"cik\"]).set_index(\n[\"ticker\", \"tag\", \"fy\", \"fp\"]\n)\n)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DataSetReader","title":"<code>DataSetReader</code>","text":"<p>Reads the data from a zip file retrieved from the SEC website.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\nclass DataSetReader:\n\"\"\"Reads the data from a zip file retrieved from the SEC website.\"\"\"\ndef __init__(self, zip_data: bytes) -&gt; None:\nself.zip_data = BytesIO(zip_data)\ndef process_zip(\nself, sec_filter: Filter, ciks: frozenset[int]\n) -&gt; Optional[pd.DataFrame]:\n\"\"\"Process a zip archive with the provided filter.\n        Args:\n            sec_filter (Filter): results to filter out of the zip archive\n            ciks (frozenset[int]): CIKs to filter data on\n        Returns:\n            Optional[pd.DataFrame]: filtered data\n        \"\"\"\nwith ZipFile(self.zip_data) as myzip:\n# Process the mapping first\nlogger.debug(\"opening sub.txt\")\nwith myzip.open(\"sub.txt\") as myfile:\n# Get reports that are 10-K or 10-Q\nsub_dataframe = DataSetReader._process_sub_text(\nmyfile, sec_filter, ciks\n)\nif sub_dataframe is None or sub_dataframe.empty:\nlogger.debug(\"nothing found in sub.txt matching the filter\")\nreturn None\nwith myzip.open(\"num.txt\") as myfile:\nreturn DataSetReader._process_num_text(\nmyfile, sec_filter, sub_dataframe\n)\n@classmethod\ndef _process_num_text(\ncls, filepath_or_buffer, sec_filter: Filter, sub_dataframe: pd.DataFrame\n) -&gt; Optional[pd.DataFrame]:\n\"\"\"Contains the numerical data.\n        adsh\ttag\tversion\tcoreg\tddate\tqtrs\tuom\tvalue\tfootnote\n        \"\"\"\nlogger.debug(\"processing num.txt\")\nreader = pd.read_csv(\nfilepath_or_buffer,\ndelimiter=\"\\t\",\nusecols=[\"adsh\", \"tag\", \"ddate\", \"uom\", \"value\"],\nindex_col=[\"adsh\", \"tag\"],\nchunksize=DEFAULT_CHUNK_SIZE,\nparse_dates=[\"ddate\"],\n)\nfiltered_data: Optional[pd.DataFrame] = None\nchunk: pd.DataFrame\nfor chunk in reader:\n# We want only the tables in left if they join on the key, so inner it is\ndata = chunk.join(sub_dataframe, how=\"inner\")\n# Additional Filtering if needed\nif sec_filter.tags is not None:\ntag_list = sec_filter.tags  # pylint: disable=unused-variable\ndata = data.query(\"tag in @tag_list\")\nif data.empty:  # pragma: no cover\n# logger.debug(f\"chunk:\\n{chunk}\")\n# logger.debug(f\"sub_dataframe:\\n{sub_dataframe}\")\ncontinue\nfiltered_data = cls.append(filtered_data, data)\n# if filtered_data is not None:  # pragma: no cover\n#     logger.debug(f\"Filtered Records (head+5): {filtered_data.head()}\")\nreturn filtered_data\n@classmethod\ndef append(\ncls, filtered_data: Optional[pd.DataFrame], data: pd.DataFrame\n) -&gt; pd.DataFrame:\n\"\"\"Append data to the filtered_data and return the updated filtered DataFrame.\n        &gt;&gt;&gt; df1 = pd.DataFrame({\"A\": [\"A0\", \"A1\", \"A2\", \"A3\"]},index=[0,1,2,3])\n        &gt;&gt;&gt; df2 = pd.DataFrame({\"B\": [\"B0\", \"B1\", \"B2\", \"B3\"]},index=[4,5,6,7])\n        &gt;&gt;&gt; DataSetReader.append(df1, df2)\n             A    B\n        0   A0  NaN\n        1   A1  NaN\n        2   A2  NaN\n        3   A3  NaN\n        4  NaN   B0\n        5  NaN   B1\n        6  NaN   B2\n        7  NaN   B3\n        &gt;&gt;&gt; DataSetReader.append(None, df1)\n            A\n        0  A0\n        1  A1\n        2  A2\n        3  A3\n        &gt;&gt;&gt; DataSetReader.append(df1, df1)\n            A\n        0  A0\n        1  A1\n        2  A2\n        3  A3\n        0  A0\n        1  A1\n        2  A2\n        3  A3\n        Args:\n            filtered_data (Optional[pd.DataFrame]): Existing Data\n            data (pd.DataFrame): New data\n        Returns:\n            pd.DataFrame: Filtered Data\n        \"\"\"\nif filtered_data is None:\nfiltered_data = data\nelse:\nfiltered_data = pd.concat([filtered_data, data])\nreturn filtered_data\n@classmethod\ndef _process_sub_text(\ncls,\nfilepath_or_buffer,\nsec_filter: Filter,\nciks: frozenset[int],  # pylint: disable=unused-argument\n) -&gt; Optional[pd.DataFrame]:\n\"\"\"Contains the submissions.\n        adsh\tcik\tname\tsic\tcountryba\tstprba\tcityba\tzipba\tbas1\tbas2\tbaph\tcountryma\n        stprma\tcityma\tzipma\tmas1\tmas2\tcountryinc\tstprinc\tein\tformer\tchanged\tafs\twksi\n        fye\tform\tperiod\tfy\tfp\tfiled\taccepted\tprevrpt\tdetail\tinstance\tnciks\taciks\n        \"\"\"\nlogger.debug(\"processing sub.txt\")\nfocus_periods = sec_filter.focus_period\noldest_fy = sec_filter.last_report.year - sec_filter.years\nquery_str = f\"cik in @ciks and fp in @focus_periods and fy &gt;= {oldest_fy}\"\n# logger.debug(f\"Query string: {query_str}\")\nreader = pd.read_csv(\nfilepath_or_buffer,\ndelimiter=\"\\t\",\nusecols=[\"adsh\", \"cik\", \"period\", \"fy\", \"fp\"],\nindex_col=[\"adsh\", \"cik\"],\nchunksize=DEFAULT_CHUNK_SIZE,\nparse_dates=[\"period\"],\ndtype={\"cik\": np.int32},\n)\nlogger.info(f\"keeping only these focus periods: {focus_periods}\")\nfiltered_data: Optional[pd.DataFrame] = None\nchunk: pd.DataFrame\nfor chunk in reader:\ndata = chunk.query(query_str)\nif data.empty:\ncontinue\nfiltered_data = cls.append(filtered_data, data)\nreturn filtered_data\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DataSetReader.append","title":"<code>append(filtered_data, data)</code>  <code>classmethod</code>","text":"<p>Append data to the filtered_data and return the updated filtered DataFrame.</p> <p>df1 = pd.DataFrame({\"A\": [\"A0\", \"A1\", \"A2\", \"A3\"]},index=[0,1,2,3]) df2 = pd.DataFrame({\"B\": [\"B0\", \"B1\", \"B2\", \"B3\"]},index=[4,5,6,7]) DataSetReader.append(df1, df2)      A    B 0   A0  NaN 1   A1  NaN 2   A2  NaN 3   A3  NaN 4  NaN   B0 5  NaN   B1 6  NaN   B2 7  NaN   B3 DataSetReader.append(None, df1)     A 0  A0 1  A1 2  A2 3  A3 DataSetReader.append(df1, df1)     A 0  A0 1  A1 2  A2 3  A3 0  A0 1  A1 2  A2 3  A3</p> <p>Parameters:</p> Name Type Description Default <code>filtered_data</code> <code>Optional[pd.DataFrame]</code> <p>Existing Data</p> required <code>data</code> <code>pd.DataFrame</code> <p>New data</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Filtered Data</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@classmethod\ndef append(\ncls, filtered_data: Optional[pd.DataFrame], data: pd.DataFrame\n) -&gt; pd.DataFrame:\n\"\"\"Append data to the filtered_data and return the updated filtered DataFrame.\n    &gt;&gt;&gt; df1 = pd.DataFrame({\"A\": [\"A0\", \"A1\", \"A2\", \"A3\"]},index=[0,1,2,3])\n    &gt;&gt;&gt; df2 = pd.DataFrame({\"B\": [\"B0\", \"B1\", \"B2\", \"B3\"]},index=[4,5,6,7])\n    &gt;&gt;&gt; DataSetReader.append(df1, df2)\n         A    B\n    0   A0  NaN\n    1   A1  NaN\n    2   A2  NaN\n    3   A3  NaN\n    4  NaN   B0\n    5  NaN   B1\n    6  NaN   B2\n    7  NaN   B3\n    &gt;&gt;&gt; DataSetReader.append(None, df1)\n        A\n    0  A0\n    1  A1\n    2  A2\n    3  A3\n    &gt;&gt;&gt; DataSetReader.append(df1, df1)\n        A\n    0  A0\n    1  A1\n    2  A2\n    3  A3\n    0  A0\n    1  A1\n    2  A2\n    3  A3\n    Args:\n        filtered_data (Optional[pd.DataFrame]): Existing Data\n        data (pd.DataFrame): New data\n    Returns:\n        pd.DataFrame: Filtered Data\n    \"\"\"\nif filtered_data is None:\nfiltered_data = data\nelse:\nfiltered_data = pd.concat([filtered_data, data])\nreturn filtered_data\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DataSetReader.process_zip","title":"<code>process_zip(sec_filter, ciks)</code>","text":"<p>Process a zip archive with the provided filter.</p> <p>Parameters:</p> Name Type Description Default <code>sec_filter</code> <code>Filter</code> <p>results to filter out of the zip archive</p> required <code>ciks</code> <code>frozenset[int]</code> <p>CIKs to filter data on</p> required <p>Returns:</p> Type Description <code>Optional[pd.DataFrame]</code> <p>Optional[pd.DataFrame]: filtered data</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def process_zip(\nself, sec_filter: Filter, ciks: frozenset[int]\n) -&gt; Optional[pd.DataFrame]:\n\"\"\"Process a zip archive with the provided filter.\n    Args:\n        sec_filter (Filter): results to filter out of the zip archive\n        ciks (frozenset[int]): CIKs to filter data on\n    Returns:\n        Optional[pd.DataFrame]: filtered data\n    \"\"\"\nwith ZipFile(self.zip_data) as myzip:\n# Process the mapping first\nlogger.debug(\"opening sub.txt\")\nwith myzip.open(\"sub.txt\") as myfile:\n# Get reports that are 10-K or 10-Q\nsub_dataframe = DataSetReader._process_sub_text(\nmyfile, sec_filter, ciks\n)\nif sub_dataframe is None or sub_dataframe.empty:\nlogger.debug(\"nothing found in sub.txt matching the filter\")\nreturn None\nwith myzip.open(\"num.txt\") as myfile:\nreturn DataSetReader._process_num_text(\nmyfile, sec_filter, sub_dataframe\n)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DownloadManager","title":"<code>DownloadManager</code>","text":"<p>This class is responsible for downloading and caching downloaded data sets from the SEC.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\nclass DownloadManager:\n\"\"\"This class is responsible for downloading and caching downloaded data sets from the SEC.\"\"\"\n# Format of zip example: 2023q1.zip\n_base_url = \"https://www.sec.gov/files/dera/data/financial-statement-data-sets\"\n_company_tickers_url = \"https://www.sec.gov/files/company_tickers.json\"\n@property\ndef ticker_reader(self) -&gt; TickerReader:\n\"\"\"Get the CIK ticker mappings. This must be done before processing reports.\n        The SEC stores the mappings of the CIK values to tickers in a JSON file.\n        We can download and cache this information essentially for a year. We're\n        not interested in companies that recently listed because they don't have a\n        long regulated record of reported earnings. When we process the records, we can\n        ignore cik values that are not in this list.\n        Typical json for these looks like the following (without spaces or line breaks):\n        {\"0\":{\"cik_str\":320193,\"ticker\":\"AAPL\",\"title\":\"Apple Inc.\"},\n         \"1\":{\"cik_str\":789019,\"ticker\":\"MSFT\",\"title\":\"MICROSOFT CORP\"},\n        Returns:\n            TickerReader: maps cik to stock ticker\n        \"\"\"\nresponse = cache.sec_tickers.get(self._company_tickers_url)\nif response.from_cache:  # pragma: no cover\nlogger.info(\"Retrieved tickers-&gt;cik mapping from cache\")\nif response.status_code == 200:  # pragma: no cover\nreturn TickerReader(response.content.decode())\nraise LookupError(\"unable to retrieve tickers\")  # pragma: no cover\ndef _create_download_uri(self, report_date: ReportDate) -&gt; str:\nfile = f\"{report_date.year}q{report_date.quarter}.zip\"\nreturn \"/\".join([self._base_url, file])\ndef get_quarterly_report(self, report_date: ReportDate) -&gt; Optional[DataSetReader]:\n\"\"\"Retrieve from a cache or make a request archived quarterly data.\n        This allows us to download data independent of actually processing it, allowing\n        us to prefetch information we need if we like.\n        Args:\n            report_date (ReportDate): information specifying the quarterly dump to retrieve\n        Returns:\n            Optional[DataSetReader]: this object helps process the data received more granularly\n        \"\"\"\nrequest = self._create_download_uri(report_date)\nresponse = cache.sec_data.get(request)\nif response.from_cache:\nlogger.info(f\"Retrieved {request} from cache\")\nif response.status_code == 200:\nreturn DataSetReader(response.content)\nreturn None  # pragma: no cover\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DownloadManager.ticker_reader","title":"<code>ticker_reader: TickerReader</code>  <code>property</code>","text":"<p>Get the CIK ticker mappings. This must be done before processing reports.</p> <p>The SEC stores the mappings of the CIK values to tickers in a JSON file. We can download and cache this information essentially for a year. We're not interested in companies that recently listed because they don't have a long regulated record of reported earnings. When we process the records, we can ignore cik values that are not in this list.</p> <p>Typical json for these looks like the following (without spaces or line breaks):</p> <p>{\"0\":{\"cik_str\":320193,\"ticker\":\"AAPL\",\"title\":\"Apple Inc.\"},  \"1\":{\"cik_str\":789019,\"ticker\":\"MSFT\",\"title\":\"MICROSOFT CORP\"},</p> <p>Returns:</p> Name Type Description <code>TickerReader</code> <code>TickerReader</code> <p>maps cik to stock ticker</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.DownloadManager.get_quarterly_report","title":"<code>get_quarterly_report(report_date)</code>","text":"<p>Retrieve from a cache or make a request archived quarterly data.</p> <p>This allows us to download data independent of actually processing it, allowing us to prefetch information we need if we like.</p> <p>Parameters:</p> Name Type Description Default <code>report_date</code> <code>ReportDate</code> <p>information specifying the quarterly dump to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[DataSetReader]</code> <p>Optional[DataSetReader]: this object helps process the data received more granularly</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def get_quarterly_report(self, report_date: ReportDate) -&gt; Optional[DataSetReader]:\n\"\"\"Retrieve from a cache or make a request archived quarterly data.\n    This allows us to download data independent of actually processing it, allowing\n    us to prefetch information we need if we like.\n    Args:\n        report_date (ReportDate): information specifying the quarterly dump to retrieve\n    Returns:\n        Optional[DataSetReader]: this object helps process the data received more granularly\n    \"\"\"\nrequest = self._create_download_uri(report_date)\nresponse = cache.sec_data.get(request)\nif response.from_cache:\nlogger.info(f\"Retrieved {request} from cache\")\nif response.status_code == 200:\nreturn DataSetReader(response.content)\nreturn None  # pragma: no cover\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Filter","title":"<code>Filter</code>  <code>dataclass</code>","text":"<p>Filter for SEC tools to scrape relevant information when processing records.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\n@dataclass(frozen=True)\nclass Filter:\n\"\"\"Filter for SEC tools to scrape relevant information when processing records.\"\"\"\nyears: int = field(hash=True)\ntags: Optional[list[str]] = field(default=None, hash=True)\nlast_report: ReportDate = field(default=ReportDate(), hash=True)\nonly_annual: bool = field(default=True, hash=True)\n@property\ndef focus_period(self) -&gt; frozenset[str]:\n\"\"\"Get the focus period for the report.\n        Companies file quarterly reports. The annual report replaces the quarterly\n        report depending on when that is reported. Typically Q4 is replaced with FY\n        for the annual reports.\n        Returns:\n            frozenset[str]: list of focus periods to use for the filter\n        \"\"\"\nif self.only_annual:\nreturn frozenset({\"FY\"})\nreturn frozenset({\"FY\", \"Q1\", \"Q2\", \"Q3\", \"Q4\"})\n@property\ndef required_reports(self) -&gt; list[ReportDate]:\n\"\"\"Get a list of required reports to download for all the quarters.\n        The list generated will include an extra quarter so that you will always be\n        able to do analysis from the current quarter to the previous quarter.\n        Also note that it doesn't matter if you specify only_annual=True. Because\n        companies don't have the same fiscal year, we have to check every quarterly\n        report just to see if their annual report is in there.\n        Returns:\n            list[ReportDate]: list of report dates to retrieve\n        \"\"\"\ndl_list: list[ReportDate] = []\nnext_report = copy.deepcopy(self.last_report)\nfinal_report = ReportDate(\nself.last_report.year - self.years, self.last_report.quarter\n)\nwhile 1:\ndl_list.append(\nReportDate(year=next_report.year, quarter=next_report.quarter)\n)\nif next_report == final_report:\nbreak\nif 1 == next_report.quarter:\nnext_report = ReportDate(year=next_report.year - 1, quarter=4)\nelse:\nnext_report = ReportDate(\nyear=next_report.year, quarter=next_report.quarter - 1\n)\nreturn dl_list\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Filter.focus_period","title":"<code>focus_period: frozenset[str]</code>  <code>property</code>","text":"<p>Get the focus period for the report.</p> <p>Companies file quarterly reports. The annual report replaces the quarterly report depending on when that is reported. Typically Q4 is replaced with FY for the annual reports.</p> <p>Returns:</p> Type Description <code>frozenset[str]</code> <p>frozenset[str]: list of focus periods to use for the filter</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Filter.required_reports","title":"<code>required_reports: list[ReportDate]</code>  <code>property</code>","text":"<p>Get a list of required reports to download for all the quarters.</p> <p>The list generated will include an extra quarter so that you will always be able to do analysis from the current quarter to the previous quarter.</p> <p>Also note that it doesn't matter if you specify only_annual=True. Because companies don't have the same fiscal year, we have to check every quarterly report just to see if their annual report is in there.</p> <p>Returns:</p> Type Description <code>list[ReportDate]</code> <p>list[ReportDate]: list of report dates to retrieve</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.ReportDate","title":"<code>ReportDate</code>  <code>dataclass</code>","text":"<p>ReportDate is used to select and identify archives created by the SEC.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\n@dataclass(frozen=True)\nclass ReportDate:\n\"\"\"ReportDate is used to select and identify archives created by the SEC.\"\"\"\nyear: int = date.today().year\nquarter: int = ((date.today().month - 1) // 3) + 1\ndef __post_init__(self):\nif self.year &gt; date.today().year:\nraise ValueError(\n\"you cannot request reports in the future...that would be illegal :)\"\n)\nif self.quarter not in range(1, 5):\nraise ValueError(\nf\"the quarter must be a value between 1 and 4 - given: {self.quarter}\"\n)\ndef __str__(self) -&gt; str:\nreturn f\"{self.year}-q{self.quarter}\"\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results","title":"<code>Results</code>  <code>dataclass</code>","text":"<p>Filtered data looks like this(in csv format):</p> <p>Note that fp has the \"Q\" removed from the front so it can be stored as a simple number.</p> <p>.. code-block:: text</p> <pre><code>ticker,tag,fy,fp,ddate,uom,value,period,title\nAAPL,EntityCommonStockSharesOutstanding,2022,Q1,2023-01-31,shares,2000.0,2022-12-31,Apple Inc.\nAAPL,FakeAttributeTag,2022,Q1,2023-01-31,shares,200.0,2022-12-31,Apple Inc.\n</code></pre> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\n@dataclass\nclass Results:\n\"\"\"Filtered data looks like this(in csv format):\n    Note that fp has the \"Q\" removed from the front so it can be stored as a simple number.\n    .. code-block:: text\n        ticker,tag,fy,fp,ddate,uom,value,period,title\n        AAPL,EntityCommonStockSharesOutstanding,2022,Q1,2023-01-31,shares,2000.0,2022-12-31,Apple Inc.\n        AAPL,FakeAttributeTag,2022,Q1,2023-01-31,shares,200.0,2022-12-31,Apple Inc.\n    \"\"\"\nfiltered_data: pd.DataFrame\n_cik_list: Optional[set[np.int64]] = None\n@beartype\n@dataclass\nclass Table:\n\"\"\"This is the results from a `Filter.select()` call.\n        The results table looks like the following:\n        ```\n        tag            AccountsPayableCurrent  ...  WeightedAverageNumberOfSharesOutstandingBasic\n        ticker fy                              ...\n        AAPL   2021.0            4.852950e+10  ...                                   1.750824e+10\n               2022.0            5.943900e+10  ...                                   1.675645e+10\n        MSFT   2021.0            1.384650e+10  ...                                   7.610000e+09\n               2022.0            1.708150e+10  ...                                   7.551000e+09\n        TMO    2021.0            2.521000e+09  ...                                   3.966667e+08\n               2022.0            3.124000e+09  ...                                   3.940000e+08\n        ```\n        From here, you can call functions on this class like `get_value()` or `normalize()`.\n        !!! note\n            To get a list of all the tags, run the `annual_reports` analysis module and search through the output for meaningful tags.\n        \"\"\"\ndata: pd.DataFrame\ndef __str__(self) -&gt; str:\nreturn str(self.data)\n@property\ndef tags(self) -&gt; np.ndarray:\n\"\"\"List of tags that can be used on this data set.\n            Returns:\n                np.ndarray: array with results\n            \"\"\"\nreturn self.data.columns.values\ndef get_value(self, ticker: str, tag: str, year: int) -&gt; int | float:\n\"\"\"Retrieve the exact value of a table cell.\n            Args:\n                ticker (str): ticker identifying the equity of interest.\n                tag (str): attribute indicating the type of data to look at.\n                year (int): The year this data applies to.\n            Returns:\n                int | float: value of result\n            \"\"\"\n# Lookup convert ticker to cik\nticker = ticker.upper()\nreturn self.data.loc[ticker].loc[year].loc[tag]\ndef normalize(self):\n\"\"\"Remove all values that are NaN.\"\"\"\nself.data = self.data.dropna(axis=1, how=\"any\")\ndef slice(\nself,\nticker: Optional[str | list[str]] = None,\nyear: Optional[int] = None,\ntags: Optional[list[str]] = None,\n) -&gt; pd.DataFrame:\n\"\"\"Slice the results by the specified values\n            Args:\n                ticker (Optional[str | list[str]]): _description_. Defaults to None.\n                tags (Optional[str]): _description_. Defaults to None.\n                year (Optional[int]): _description_. Defaults to None.\n            Returns:\n                pd.DataFrame: _description_\n            \"\"\"\nresult = self.data\nif ticker:\nif isinstance(ticker, str):\nticker = ticker.upper()\nelse:\nticker = [t.upper() for t in ticker]\nresult = result.loc(axis=0)[ticker, :]\nif year:\nresult = result.loc(axis=0)[:, year, :]\nif tags:\nresult = pd.DataFrame(result.loc[:, tags], columns=tags)\nreturn result\ndef calculate_net_income(self, column_name: str):\n\"\"\"Calculates the net income stocks as a series.\n            !!! example\n                ``` python\n                results.calculate_net_income()\n                ```\n            Args:\n                column_name (str): name to assign to the column\n            \"\"\"\nself.data[column_name] = self.data[\"OperatingIncomeLoss\"]\ndef calculate_current_ratio(self, column_name: str):\n\"\"\"Calculate the current ratio.\n            The current ratio is a liquidity ratio that measures a company\u2019s\n            ability to pay short-term obligations or those due within one year.\n            Args:\n                column_name (str): _description_\n            \"\"\"\nself.data[column_name] = (\nself.data[\"AssetsCurrent\"] / self.data[\"LiabilitiesCurrent\"]\n)\ndef calculate_debt_to_assets(self, column_name: str):\n\"\"\"Calculates the current debt to assets ratio.\n            Having more debt than assets is a risk indicator that could indicate\n            a potential for bankruptcy.\n            Args:\n                column_name (str): name to assign to the column\n            \"\"\"\nself.data[column_name] = (\nself.data[\"LiabilitiesCurrent\"] / self.data[\"AssetsCurrent\"]\n)\ndef calculate_return_on_assets(self, column_name: str):\n\"\"\"Returns the ROA of stocks as a series.\n            !!! example\n                ``` python\n                results.calculate_return_on_assets('ROA')\n                ```\n            Args:\n                column_name (str): name to assign to the column\n            \"\"\"\nself.data[column_name] = self.data[\"OperatingIncomeLoss\"].div(\nself.data[\"Assets\"]\n)\ndef calculate_delta(self, column_name: str, delta_of: str):\n\"\"\"Calculate the change between the latest row and the one before it within a ticker.\n            Args:\n                column_name (str): name to give the calculated column\n                delta_of (str): column name to calculate the delta of, such as ROI\n            \"\"\"\nself.data[column_name] = self.data.groupby(by=[\"ticker\"]).diff()[delta_of]\ndef select(\nself,\naggregate_func: Optional[\nCallable | Literal[\"mean\", \"std\", \"var\", \"sum\", \"min\", \"max\", \"slope\"]\n] = \"mean\",\ntickers: Optional[Sequence[str]] = None,\n) -&gt; Table:\n\"\"\"Select only a subset of the data matching the specified criteria.\n        Args:\n            aggregate_func (Optional[Callable | Literal['mean', 'std', 'var', 'sum', 'min','max','slope']]): Numpy function to use for aggregating the results. This should be a function like `numpy.average` or `numpy.sum`.\n            tickers (Optional[Sequence[str]]): ticker symbol for the company\n        Returns:\n            Results.Table: Object that represents a pivot table with the data requested\n        \"\"\"\nassert self.filtered_data is not None\nif tickers is not None:\ntickers = [t.upper() for t in tickers]\nlogger.debug(f\"ticker filter: {tickers}\")\ndata = (\nself.filtered_data\nif tickers is None\nelse self.filtered_data.query(\"ticker in @tickers\")\n)\nlogger.debug(f\"pre-pivot:\\n{data}\")\n# Try and see if the function exists\nif isinstance(aggregate_func, str):\nif aggregate_func in globals():\naggregate_func = globals()[aggregate_func]\ntable: pd.DataFrame = pd.pivot_table(\ndata,\nvalues=\"value\",\ncolumns=\"tag\",\nindex=[\"ticker\", \"fy\"],\naggfunc=aggregate_func,\n)\nreturn Results.Table(table)\n@property\ndef ciks(self) -&gt; set[np.int64]:\n\"\"\"Retrieves a list of CIK values corresponding to the tickers being looked up.\n        The SEC object will call populateCikList to generate this information. This helps\n        with dependency injection by avoiding the Filter having to maintain references to\n        these helper objects for temporary processing. It also lets us stub out the information\n        provided without having to involve heavier utilities or network access.\n        Raises:\n            LookupError: _description_\n        Returns:\n            set[int]: Set containing all the CIKs that are being filtered out\n        \"\"\"\nif self._cik_list is None:\nraise LookupError(\n\"Filter was not provided a mapping of cik's based on the tickers.\"\n)\nreturn self._cik_list\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.ciks","title":"<code>ciks: set[np.int64]</code>  <code>property</code>","text":"<p>Retrieves a list of CIK values corresponding to the tickers being looked up.</p> <p>The SEC object will call populateCikList to generate this information. This helps with dependency injection by avoiding the Filter having to maintain references to these helper objects for temporary processing. It also lets us stub out the information provided without having to involve heavier utilities or network access.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>description</p> <p>Returns:</p> Type Description <code>set[np.int64]</code> <p>set[int]: Set containing all the CIKs that are being filtered out</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table","title":"<code>Table</code>  <code>dataclass</code>","text":"<p>This is the results from a <code>Filter.select()</code> call.</p> <p>The results table looks like the following:</p> <pre><code>tag            AccountsPayableCurrent  ...  WeightedAverageNumberOfSharesOutstandingBasic\nticker fy                              ...\nAAPL   2021.0            4.852950e+10  ...                                   1.750824e+10\n       2022.0            5.943900e+10  ...                                   1.675645e+10\nMSFT   2021.0            1.384650e+10  ...                                   7.610000e+09\n       2022.0            1.708150e+10  ...                                   7.551000e+09\nTMO    2021.0            2.521000e+09  ...                                   3.966667e+08\n       2022.0            3.124000e+09  ...                                   3.940000e+08\n</code></pre> <p>From here, you can call functions on this class like <code>get_value()</code> or <code>normalize()</code>.</p> <p>Note</p> <p>To get a list of all the tags, run the <code>annual_reports</code> analysis module and search through the output for meaningful tags.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\n@dataclass\nclass Table:\n\"\"\"This is the results from a `Filter.select()` call.\n    The results table looks like the following:\n    ```\n    tag            AccountsPayableCurrent  ...  WeightedAverageNumberOfSharesOutstandingBasic\n    ticker fy                              ...\n    AAPL   2021.0            4.852950e+10  ...                                   1.750824e+10\n           2022.0            5.943900e+10  ...                                   1.675645e+10\n    MSFT   2021.0            1.384650e+10  ...                                   7.610000e+09\n           2022.0            1.708150e+10  ...                                   7.551000e+09\n    TMO    2021.0            2.521000e+09  ...                                   3.966667e+08\n           2022.0            3.124000e+09  ...                                   3.940000e+08\n    ```\n    From here, you can call functions on this class like `get_value()` or `normalize()`.\n    !!! note\n        To get a list of all the tags, run the `annual_reports` analysis module and search through the output for meaningful tags.\n    \"\"\"\ndata: pd.DataFrame\ndef __str__(self) -&gt; str:\nreturn str(self.data)\n@property\ndef tags(self) -&gt; np.ndarray:\n\"\"\"List of tags that can be used on this data set.\n        Returns:\n            np.ndarray: array with results\n        \"\"\"\nreturn self.data.columns.values\ndef get_value(self, ticker: str, tag: str, year: int) -&gt; int | float:\n\"\"\"Retrieve the exact value of a table cell.\n        Args:\n            ticker (str): ticker identifying the equity of interest.\n            tag (str): attribute indicating the type of data to look at.\n            year (int): The year this data applies to.\n        Returns:\n            int | float: value of result\n        \"\"\"\n# Lookup convert ticker to cik\nticker = ticker.upper()\nreturn self.data.loc[ticker].loc[year].loc[tag]\ndef normalize(self):\n\"\"\"Remove all values that are NaN.\"\"\"\nself.data = self.data.dropna(axis=1, how=\"any\")\ndef slice(\nself,\nticker: Optional[str | list[str]] = None,\nyear: Optional[int] = None,\ntags: Optional[list[str]] = None,\n) -&gt; pd.DataFrame:\n\"\"\"Slice the results by the specified values\n        Args:\n            ticker (Optional[str | list[str]]): _description_. Defaults to None.\n            tags (Optional[str]): _description_. Defaults to None.\n            year (Optional[int]): _description_. Defaults to None.\n        Returns:\n            pd.DataFrame: _description_\n        \"\"\"\nresult = self.data\nif ticker:\nif isinstance(ticker, str):\nticker = ticker.upper()\nelse:\nticker = [t.upper() for t in ticker]\nresult = result.loc(axis=0)[ticker, :]\nif year:\nresult = result.loc(axis=0)[:, year, :]\nif tags:\nresult = pd.DataFrame(result.loc[:, tags], columns=tags)\nreturn result\ndef calculate_net_income(self, column_name: str):\n\"\"\"Calculates the net income stocks as a series.\n        !!! example\n            ``` python\n            results.calculate_net_income()\n            ```\n        Args:\n            column_name (str): name to assign to the column\n        \"\"\"\nself.data[column_name] = self.data[\"OperatingIncomeLoss\"]\ndef calculate_current_ratio(self, column_name: str):\n\"\"\"Calculate the current ratio.\n        The current ratio is a liquidity ratio that measures a company\u2019s\n        ability to pay short-term obligations or those due within one year.\n        Args:\n            column_name (str): _description_\n        \"\"\"\nself.data[column_name] = (\nself.data[\"AssetsCurrent\"] / self.data[\"LiabilitiesCurrent\"]\n)\ndef calculate_debt_to_assets(self, column_name: str):\n\"\"\"Calculates the current debt to assets ratio.\n        Having more debt than assets is a risk indicator that could indicate\n        a potential for bankruptcy.\n        Args:\n            column_name (str): name to assign to the column\n        \"\"\"\nself.data[column_name] = (\nself.data[\"LiabilitiesCurrent\"] / self.data[\"AssetsCurrent\"]\n)\ndef calculate_return_on_assets(self, column_name: str):\n\"\"\"Returns the ROA of stocks as a series.\n        !!! example\n            ``` python\n            results.calculate_return_on_assets('ROA')\n            ```\n        Args:\n            column_name (str): name to assign to the column\n        \"\"\"\nself.data[column_name] = self.data[\"OperatingIncomeLoss\"].div(\nself.data[\"Assets\"]\n)\ndef calculate_delta(self, column_name: str, delta_of: str):\n\"\"\"Calculate the change between the latest row and the one before it within a ticker.\n        Args:\n            column_name (str): name to give the calculated column\n            delta_of (str): column name to calculate the delta of, such as ROI\n        \"\"\"\nself.data[column_name] = self.data.groupby(by=[\"ticker\"]).diff()[delta_of]\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.tags","title":"<code>tags: np.ndarray</code>  <code>property</code>","text":"<p>List of tags that can be used on this data set.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: array with results</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.calculate_current_ratio","title":"<code>calculate_current_ratio(column_name)</code>","text":"<p>Calculate the current ratio.</p> <p>The current ratio is a liquidity ratio that measures a company\u2019s ability to pay short-term obligations or those due within one year.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>description</p> required Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def calculate_current_ratio(self, column_name: str):\n\"\"\"Calculate the current ratio.\n    The current ratio is a liquidity ratio that measures a company\u2019s\n    ability to pay short-term obligations or those due within one year.\n    Args:\n        column_name (str): _description_\n    \"\"\"\nself.data[column_name] = (\nself.data[\"AssetsCurrent\"] / self.data[\"LiabilitiesCurrent\"]\n)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.calculate_debt_to_assets","title":"<code>calculate_debt_to_assets(column_name)</code>","text":"<p>Calculates the current debt to assets ratio.</p> <p>Having more debt than assets is a risk indicator that could indicate a potential for bankruptcy.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>name to assign to the column</p> required Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def calculate_debt_to_assets(self, column_name: str):\n\"\"\"Calculates the current debt to assets ratio.\n    Having more debt than assets is a risk indicator that could indicate\n    a potential for bankruptcy.\n    Args:\n        column_name (str): name to assign to the column\n    \"\"\"\nself.data[column_name] = (\nself.data[\"LiabilitiesCurrent\"] / self.data[\"AssetsCurrent\"]\n)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.calculate_delta","title":"<code>calculate_delta(column_name, delta_of)</code>","text":"<p>Calculate the change between the latest row and the one before it within a ticker.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>name to give the calculated column</p> required <code>delta_of</code> <code>str</code> <p>column name to calculate the delta of, such as ROI</p> required Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def calculate_delta(self, column_name: str, delta_of: str):\n\"\"\"Calculate the change between the latest row and the one before it within a ticker.\n    Args:\n        column_name (str): name to give the calculated column\n        delta_of (str): column name to calculate the delta of, such as ROI\n    \"\"\"\nself.data[column_name] = self.data.groupby(by=[\"ticker\"]).diff()[delta_of]\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.calculate_net_income","title":"<code>calculate_net_income(column_name)</code>","text":"<p>Calculates the net income stocks as a series.</p> <p>Example</p> <pre><code>results.calculate_net_income()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>name to assign to the column</p> required Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def calculate_net_income(self, column_name: str):\n\"\"\"Calculates the net income stocks as a series.\n    !!! example\n        ``` python\n        results.calculate_net_income()\n        ```\n    Args:\n        column_name (str): name to assign to the column\n    \"\"\"\nself.data[column_name] = self.data[\"OperatingIncomeLoss\"]\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.calculate_return_on_assets","title":"<code>calculate_return_on_assets(column_name)</code>","text":"<p>Returns the ROA of stocks as a series.</p> <p>Example</p> <pre><code>results.calculate_return_on_assets('ROA')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>name to assign to the column</p> required Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def calculate_return_on_assets(self, column_name: str):\n\"\"\"Returns the ROA of stocks as a series.\n    !!! example\n        ``` python\n        results.calculate_return_on_assets('ROA')\n        ```\n    Args:\n        column_name (str): name to assign to the column\n    \"\"\"\nself.data[column_name] = self.data[\"OperatingIncomeLoss\"].div(\nself.data[\"Assets\"]\n)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.get_value","title":"<code>get_value(ticker, tag, year)</code>","text":"<p>Retrieve the exact value of a table cell.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>ticker identifying the equity of interest.</p> required <code>tag</code> <code>str</code> <p>attribute indicating the type of data to look at.</p> required <code>year</code> <code>int</code> <p>The year this data applies to.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>int | float: value of result</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def get_value(self, ticker: str, tag: str, year: int) -&gt; int | float:\n\"\"\"Retrieve the exact value of a table cell.\n    Args:\n        ticker (str): ticker identifying the equity of interest.\n        tag (str): attribute indicating the type of data to look at.\n        year (int): The year this data applies to.\n    Returns:\n        int | float: value of result\n    \"\"\"\n# Lookup convert ticker to cik\nticker = ticker.upper()\nreturn self.data.loc[ticker].loc[year].loc[tag]\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.normalize","title":"<code>normalize()</code>","text":"<p>Remove all values that are NaN.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def normalize(self):\n\"\"\"Remove all values that are NaN.\"\"\"\nself.data = self.data.dropna(axis=1, how=\"any\")\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.Table.slice","title":"<code>slice(ticker=None, year=None, tags=None)</code>","text":"<p>Slice the results by the specified values</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>Optional[str | list[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>tags</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> <code>year</code> <code>Optional[int]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: description</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def slice(\nself,\nticker: Optional[str | list[str]] = None,\nyear: Optional[int] = None,\ntags: Optional[list[str]] = None,\n) -&gt; pd.DataFrame:\n\"\"\"Slice the results by the specified values\n    Args:\n        ticker (Optional[str | list[str]]): _description_. Defaults to None.\n        tags (Optional[str]): _description_. Defaults to None.\n        year (Optional[int]): _description_. Defaults to None.\n    Returns:\n        pd.DataFrame: _description_\n    \"\"\"\nresult = self.data\nif ticker:\nif isinstance(ticker, str):\nticker = ticker.upper()\nelse:\nticker = [t.upper() for t in ticker]\nresult = result.loc(axis=0)[ticker, :]\nif year:\nresult = result.loc(axis=0)[:, year, :]\nif tags:\nresult = pd.DataFrame(result.loc[:, tags], columns=tags)\nreturn result\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.Results.select","title":"<code>select(aggregate_func='mean', tickers=None)</code>","text":"<p>Select only a subset of the data matching the specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>aggregate_func</code> <code>Optional[Callable | Literal['mean', 'std', 'var', 'sum', 'min', 'max', 'slope']]</code> <p>Numpy function to use for aggregating the results. This should be a function like <code>numpy.average</code> or <code>numpy.sum</code>.</p> <code>'mean'</code> <code>tickers</code> <code>Optional[Sequence[str]]</code> <p>ticker symbol for the company</p> <code>None</code> <p>Returns:</p> Type Description <code>Table</code> <p>Results.Table: Object that represents a pivot table with the data requested</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def select(\nself,\naggregate_func: Optional[\nCallable | Literal[\"mean\", \"std\", \"var\", \"sum\", \"min\", \"max\", \"slope\"]\n] = \"mean\",\ntickers: Optional[Sequence[str]] = None,\n) -&gt; Table:\n\"\"\"Select only a subset of the data matching the specified criteria.\n    Args:\n        aggregate_func (Optional[Callable | Literal['mean', 'std', 'var', 'sum', 'min','max','slope']]): Numpy function to use for aggregating the results. This should be a function like `numpy.average` or `numpy.sum`.\n        tickers (Optional[Sequence[str]]): ticker symbol for the company\n    Returns:\n        Results.Table: Object that represents a pivot table with the data requested\n    \"\"\"\nassert self.filtered_data is not None\nif tickers is not None:\ntickers = [t.upper() for t in tickers]\nlogger.debug(f\"ticker filter: {tickers}\")\ndata = (\nself.filtered_data\nif tickers is None\nelse self.filtered_data.query(\"ticker in @tickers\")\n)\nlogger.debug(f\"pre-pivot:\\n{data}\")\n# Try and see if the function exists\nif isinstance(aggregate_func, str):\nif aggregate_func in globals():\naggregate_func = globals()[aggregate_func]\ntable: pd.DataFrame = pd.pivot_table(\ndata,\nvalues=\"value\",\ncolumns=\"tag\",\nindex=[\"ticker\", \"fy\"],\naggfunc=aggregate_func,\n)\nreturn Results.Table(table)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.TickerReader","title":"<code>TickerReader</code>","text":"<p>This class provides translation services for CIK and Ticker values.</p> <p>The SEC has a <code>json</code> file that provides mappings from CIK values to Tickers. The data providing this conversion is injected into this class and then this class provides helper methods for performing the conversion on this data set.</p> <p>This class is provided CSV data which is parsed upon initialization. So creating this object is the most expensive part.</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\nclass TickerReader:\n\"\"\"This class provides translation services for CIK and Ticker values.\n    The SEC has a `json` file that provides mappings from CIK values to Tickers.\n    The data providing this conversion is injected into this class and then\n    this class provides helper methods for performing the conversion on this data set.\n    This class is provided CSV data which is parsed upon initialization. So creating\n    this object is the most expensive part.\n    \"\"\"\ndef __init__(self, data: str):\nself._cik_to_ticker_map = pd.read_json(data, orient=\"index\")\n@property\ndef map_of_cik_to_ticker(self) -&gt; pd.DataFrame:\n\"\"\"Dataframe containing mapping of cik and ticker information.\n        Returns:\n            pd.DataFrame: Dataframe with mapping information\n        \"\"\"\nreturn self._cik_to_ticker_map\ndef convert_to_cik(self, ticker: str) -&gt; np.int64:\n\"\"\"Get the Cik from the stock ticker.\n        Args:\n            ticker (str): stock ticker. The case does not matter.\n        Raises:\n            LookupError: If ticker is not found\n        Returns:\n            np.int64: cik\n        \"\"\"\nresult = self.map_of_cik_to_ticker[\nself.map_of_cik_to_ticker[\"ticker\"] == ticker.upper()\n]\nif result.empty:\nraise LookupError(f\"unable to find ticker: {ticker}\")\nreturn result.cik_str.iloc[0]\ndef convert_to_ticker(self, cik: int) -&gt; str:\n\"\"\"Get the stock ticker from the Cik number.\n        Args:\n            cik (int): Cik number for the stock\n        Returns:\n            str: stock ticker\n        \"\"\"\nresult = self.map_of_cik_to_ticker[self.map_of_cik_to_ticker[\"cik_str\"] == cik]\nreturn result.ticker.iloc[0]\ndef contains(self, tickers: frozenset) -&gt; bool:\n\"\"\"Check that the tickers provided exist.\n        Args:\n            tickers (frozenset): tickers to check\n        Returns:\n            bool: if all the tickers are found\n        \"\"\"\nfor ticker in tickers:\nself.convert_to_cik(ticker)\nreturn True\ndef get_ciks(self, tickers: frozenset[str]) -&gt; frozenset[int]:\n\"\"\"Populates the filter's CIK list to be used for filtering.\n        The Filter doesn't need the ticker symbols. If we expand to other data sources,\n        we would have to repeat ticker symbols. For now, the only info we need in the\n        report is the CIK values to find the corresponding stocks.\n        Args:\n            tickers (frozenset[str]): ticker symbols to search for\n        Returns:\n            frozenset[int]: CIKs values translated from the tickers specified\n        \"\"\"\ncik_list: set[int] = set()\nfor ticker in tickers:\ncik = self.convert_to_cik(ticker)\ncik_list.add(int(cik))\nreturn frozenset(cik_list)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.TickerReader.map_of_cik_to_ticker","title":"<code>map_of_cik_to_ticker: pd.DataFrame</code>  <code>property</code>","text":"<p>Dataframe containing mapping of cik and ticker information.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Dataframe with mapping information</p>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.TickerReader.contains","title":"<code>contains(tickers)</code>","text":"<p>Check that the tickers provided exist.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>frozenset</code> <p>tickers to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if all the tickers are found</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def contains(self, tickers: frozenset) -&gt; bool:\n\"\"\"Check that the tickers provided exist.\n    Args:\n        tickers (frozenset): tickers to check\n    Returns:\n        bool: if all the tickers are found\n    \"\"\"\nfor ticker in tickers:\nself.convert_to_cik(ticker)\nreturn True\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.TickerReader.convert_to_cik","title":"<code>convert_to_cik(ticker)</code>","text":"<p>Get the Cik from the stock ticker.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>stock ticker. The case does not matter.</p> required <p>Raises:</p> Type Description <code>LookupError</code> <p>If ticker is not found</p> <p>Returns:</p> Type Description <code>np.int64</code> <p>np.int64: cik</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def convert_to_cik(self, ticker: str) -&gt; np.int64:\n\"\"\"Get the Cik from the stock ticker.\n    Args:\n        ticker (str): stock ticker. The case does not matter.\n    Raises:\n        LookupError: If ticker is not found\n    Returns:\n        np.int64: cik\n    \"\"\"\nresult = self.map_of_cik_to_ticker[\nself.map_of_cik_to_ticker[\"ticker\"] == ticker.upper()\n]\nif result.empty:\nraise LookupError(f\"unable to find ticker: {ticker}\")\nreturn result.cik_str.iloc[0]\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.TickerReader.convert_to_ticker","title":"<code>convert_to_ticker(cik)</code>","text":"<p>Get the stock ticker from the Cik number.</p> <p>Parameters:</p> Name Type Description Default <code>cik</code> <code>int</code> <p>Cik number for the stock</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>stock ticker</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def convert_to_ticker(self, cik: int) -&gt; str:\n\"\"\"Get the stock ticker from the Cik number.\n    Args:\n        cik (int): Cik number for the stock\n    Returns:\n        str: stock ticker\n    \"\"\"\nresult = self.map_of_cik_to_ticker[self.map_of_cik_to_ticker[\"cik_str\"] == cik]\nreturn result.ticker.iloc[0]\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.TickerReader.get_ciks","title":"<code>get_ciks(tickers)</code>","text":"<p>Populates the filter's CIK list to be used for filtering.</p> <p>The Filter doesn't need the ticker symbols. If we expand to other data sources, we would have to repeat ticker symbols. For now, the only info we need in the report is the CIK values to find the corresponding stocks.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>frozenset[str]</code> <p>ticker symbols to search for</p> required <p>Returns:</p> Type Description <code>frozenset[int]</code> <p>frozenset[int]: CIKs values translated from the tickers specified</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def get_ciks(self, tickers: frozenset[str]) -&gt; frozenset[int]:\n\"\"\"Populates the filter's CIK list to be used for filtering.\n    The Filter doesn't need the ticker symbols. If we expand to other data sources,\n    we would have to repeat ticker symbols. For now, the only info we need in the\n    report is the CIK values to find the corresponding stocks.\n    Args:\n        tickers (frozenset[str]): ticker symbols to search for\n    Returns:\n        frozenset[int]: CIKs values translated from the tickers specified\n    \"\"\"\ncik_list: set[int] = set()\nfor ticker in tickers:\ncik = self.convert_to_cik(ticker)\ncik_list.add(int(cik))\nreturn frozenset(cik_list)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.filter_data","title":"<code>filter_data(tickers, sec_filter, download_manager=DownloadManager())</code>","text":"<p>Initiate the retrieval of ticker information based on the provided filters.</p> <p>Filtered data is stored with the filter</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>list[str]</code> <p>ticker symbols you want information about</p> required <code>sec_filter</code> <code>Filter</code> <p>SEC specific data to scrape from the reports</p> required <code>download_manager</code> <code>DownloadManager</code> <p>download manager to use</p> <code>DownloadManager()</code> <p>Returns:</p> Name Type Description <code>Results</code> <code>Results</code> <p>results with filtered data</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\n@cache.results.memoize(tag=\"sec\", ignore=(\"download_manager\"))\ndef filter_data(\ntickers: list[str],\nsec_filter: Filter,\ndownload_manager: DownloadManager = DownloadManager(),\n) -&gt; Results:\n\"\"\"Initiate the retrieval of ticker information based on the provided filters.\n    Filtered data is stored with the filter\n    Args:\n        tickers (list[str]): ticker symbols you want information about\n        sec_filter (Filter): SEC specific data to scrape from the reports\n        download_manager (DownloadManager): download manager to use\n    Returns:\n        Results: results with filtered data\n    \"\"\"\nlogger.debug(f\"tickers:\\n{repr(tickers)}\")\nlogger.debug(f\"sec_filter:\\n{repr(sec_filter)}\")\nreturn filter_data_nocache(frozenset(tickers), sec_filter, download_manager)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.filter_data_nocache","title":"<code>filter_data_nocache(tickers, sec_filter, download_manager=DownloadManager())</code>","text":"<p>Same as filter_data but no caching is applied.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>frozenset[str]</code> <p>ticker symbols you want information about</p> required <code>sec_filter</code> <code>Filter</code> <p>SEC specific data to scrape from the reports</p> required <code>download_manager</code> <code>DownloadManager</code> <p>download manager to use</p> <code>DownloadManager()</code> <p>Returns:</p> Name Type Description <code>Results</code> <code>Results</code> <p>results with filtered data</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>def filter_data_nocache(\ntickers: frozenset[str],\nsec_filter: Filter,\ndownload_manager: DownloadManager = DownloadManager(),\n) -&gt; Results:\n\"\"\"Same as filter_data but no caching is applied.\n    Args:\n        tickers (frozenset[str]): ticker symbols you want information about\n        sec_filter (Filter): SEC specific data to scrape from the reports\n        download_manager (DownloadManager): download manager to use\n    Returns:\n        Results: results with filtered data\n    \"\"\"\ncollector = DataSetCollector(download_manager)\nticker_reader = download_manager.ticker_reader\n# Returns true or throws\nticker_reader.contains(tickers)\nciks = ticker_reader.get_ciks(tickers=tickers)\nreturn collector.get_data(sec_filter, ciks)\n</code></pre>"},{"location":"reference/src/stocktracer/collector/sec/#src.stocktracer.collector.sec.slope","title":"<code>slope(data, order=1)</code>","text":"<p>Calculate the trend of a series.</p> <p>import math math.isclose(slope(pd.Series((1,2,3))), 1) True</p> <p>math.isclose(slope(pd.Series((3,2,1))), -1) True</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.Series</code> <p>description</p> required <code>order</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>slope of the trend line</p> Source code in <code>src/stocktracer/collector/sec.py</code> <pre><code>@beartype\ndef slope(data: pd.Series, order: int = 1) -&gt; float:\n\"\"\"Calculate the trend of a series.\n    &gt;&gt;&gt; import math\n    &gt;&gt;&gt; math.isclose(slope(pd.Series((1,2,3))), 1)\n    True\n    &gt;&gt;&gt; math.isclose(slope(pd.Series((3,2,1))), -1)\n    True\n    Args:\n        data (pd.Series): _description_\n        order (int): _description_. Defaults to 1.\n    Returns:\n        float: slope of the trend line\n    \"\"\"\nx_axis = range(len(data.keys()))\ny_axis = data.values\ntry:\n# An exception can be thrown if there's only one element of it's a nan\ncoeffs = np.polyfit(x_axis, y_axis, order)\nexcept np.linalg.LinAlgError:\nreturn float(0)\nexcept Exception as e:\nlogger.warning(f\"slope exception: {e}\")\nreturn float(0)\nreturn coeffs[0]\n</code></pre>"}]}